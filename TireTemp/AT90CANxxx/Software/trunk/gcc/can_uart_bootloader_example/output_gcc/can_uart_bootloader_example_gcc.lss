
can_uart_bootloader_example_gcc.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  0001ffdc  00002090  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fdc  0001e000  0001e000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bootconf     0000000a  0001fff0  0001fff0  0000209a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .flashapi     00000006  0001fffa  0001fffa  000020a4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .bss          00000154  0080010a  0080010a  000020aa  2**0
                  ALLOC
  5 .stab         00000408  00000000  00000000  000020ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000084  00000000  00000000  000024b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000188  00000000  00000000  00002538  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000705  00000000  00000000  000026c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00001b43  00000000  00000000  00002dc5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000bcb  00000000  00000000  00004908  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000028e1  00000000  00000000  000054d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000003f0  00000000  00000000  00007db4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000a47  00000000  00000000  000081a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00001111  00000000  00000000  00008beb  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

0001e000 <__vectors>:
   1e000:	0c 94 4a f0 	jmp	0x1e094	; 0x1e094 <__ctors_end>
   1e004:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e008:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e00c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e010:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e014:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e018:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e01c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e020:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e024:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e028:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e02c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e030:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e034:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e038:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e03c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e040:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e044:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e048:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e04c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e050:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e054:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e058:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e05c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e060:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e064:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e068:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e06c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e070:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e074:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e078:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e07c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e080:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e084:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e088:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e08c:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>
   1e090:	0c 94 67 f0 	jmp	0x1e0ce	; 0x1e0ce <__bad_interrupt>

0001e094 <__ctors_end>:
   1e094:	11 24       	eor	r1, r1
   1e096:	1f be       	out	0x3f, r1	; 63
   1e098:	cf ef       	ldi	r28, 0xFF	; 255
   1e09a:	d0 e1       	ldi	r29, 0x10	; 16
   1e09c:	de bf       	out	0x3e, r29	; 62
   1e09e:	cd bf       	out	0x3d, r28	; 61

0001e0a0 <__do_copy_data>:
   1e0a0:	11 e0       	ldi	r17, 0x01	; 1
   1e0a2:	a0 e0       	ldi	r26, 0x00	; 0
   1e0a4:	b1 e0       	ldi	r27, 0x01	; 1
   1e0a6:	ec ed       	ldi	r30, 0xDC	; 220
   1e0a8:	ff ef       	ldi	r31, 0xFF	; 255
   1e0aa:	01 e0       	ldi	r16, 0x01	; 1
   1e0ac:	0b bf       	out	0x3b, r16	; 59
   1e0ae:	02 c0       	rjmp	.+4      	; 0x1e0b4 <__do_copy_data+0x14>
   1e0b0:	07 90       	elpm	r0, Z+
   1e0b2:	0d 92       	st	X+, r0
   1e0b4:	aa 30       	cpi	r26, 0x0A	; 10
   1e0b6:	b1 07       	cpc	r27, r17
   1e0b8:	d9 f7       	brne	.-10     	; 0x1e0b0 <__do_copy_data+0x10>

0001e0ba <__do_clear_bss>:
   1e0ba:	12 e0       	ldi	r17, 0x02	; 2
   1e0bc:	aa e0       	ldi	r26, 0x0A	; 10
   1e0be:	b1 e0       	ldi	r27, 0x01	; 1
   1e0c0:	01 c0       	rjmp	.+2      	; 0x1e0c4 <.do_clear_bss_start>

0001e0c2 <.do_clear_bss_loop>:
   1e0c2:	1d 92       	st	X+, r1

0001e0c4 <.do_clear_bss_start>:
   1e0c4:	ae 35       	cpi	r26, 0x5E	; 94
   1e0c6:	b1 07       	cpc	r27, r17
   1e0c8:	e1 f7       	brne	.-8      	; 0x1e0c2 <.do_clear_bss_loop>
   1e0ca:	0c 94 69 f0 	jmp	0x1e0d2	; 0x1e0d2 <main>

0001e0ce <__bad_interrupt>:
   1e0ce:	0c 94 00 f0 	jmp	0x1e000	; 0x1e000 <__vectors>

0001e0d2 <main>:
//! @return Integer 0
//!
//------------------------------------------------------------------------------
int main (void)
{
   1e0d2:	0f 93       	push	r16
   1e0d4:	1f 93       	push	r17
    U8      u8_temp;
    U8      hwcb = FALSE;
    Bool    auto_b = 0;

//! --- First of all, disabling the Global Interrupt
    Disable_interrupt();
   1e0d6:	f8 94       	cli

//! --- If comming from RESET then test of the HardWare Condition Bit
    if (MCUSR != 0)
   1e0d8:	84 b7       	in	r24, 0x34	; 52
   1e0da:	88 23       	and	r24, r24
   1e0dc:	11 f1       	breq	.+68     	; 0x1e122 <main+0x50>
    {
        //- Clear all reset flags
        MCUSR = 0;
   1e0de:	14 be       	out	0x34, r1	; 52
        //- Get HWCB (HardWare Condition Bit)
        HWCB_PORT_DIR &= ~(1<<HWCB_INPUT_PIN);      // HWCB pin in input
   1e0e0:	50 98       	cbi	0x0a, 0	; 10
        if (HWCB_PULLUP_ON == 1)
        {
            HWCB_PORT_OUT |= (1<<HWCB_INPUT_PIN);   // Pull-up on HWCB
   1e0e2:	58 9a       	sbi	0x0b, 0	; 11
        }
        hwcb = HWCB_PORT_IN;
   1e0e4:	09 b1       	in	r16, 0x09	; 9
        if (HWCB_ACTIVE_LEVEL == 0)
        {
            hwcb = ((~hwcb)&(1<<HWCB_INPUT_PIN));
   1e0e6:	00 95       	com	r16
   1e0e8:	01 70       	andi	r16, 0x01	; 1
        }

        //- Start application else start boot loader
        u8_temp = get_conf_byte(BSB);
   1e0ea:	80 ef       	ldi	r24, 0xF0	; 240
   1e0ec:	9f ef       	ldi	r25, 0xFF	; 255
   1e0ee:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>

        if ( ((u8_temp!=BSB_DEFAULT)&&(hwcb==0)) || ((u8_temp==BSB_DEFAULT)&&(hwcb!=0)) )
   1e0f2:	8f 3f       	cpi	r24, 0xFF	; 255
   1e0f4:	19 f0       	breq	.+6      	; 0x1e0fc <main+0x2a>
   1e0f6:	00 23       	and	r16, r16
   1e0f8:	19 f0       	breq	.+6      	; 0x1e100 <main+0x2e>
   1e0fa:	13 c0       	rjmp	.+38     	; 0x1e122 <main+0x50>
   1e0fc:	00 23       	and	r16, r16
   1e0fe:	89 f0       	breq	.+34     	; 0x1e122 <main+0x50>
        {
            isp_jump_to ( (((U16)get_conf_byte(SA_H))<<8) | ((U16)get_conf_byte(SA_L)) );   // Start application
   1e100:	88 ef       	ldi	r24, 0xF8	; 248
   1e102:	9f ef       	ldi	r25, 0xFF	; 255
   1e104:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e108:	08 2f       	mov	r16, r24
   1e10a:	89 ef       	ldi	r24, 0xF9	; 249
   1e10c:	9f ef       	ldi	r25, 0xFF	; 255
   1e10e:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e112:	11 27       	eor	r17, r17
   1e114:	10 2f       	mov	r17, r16
   1e116:	00 27       	eor	r16, r16
   1e118:	99 27       	eor	r25, r25
   1e11a:	80 2b       	or	r24, r16
   1e11c:	91 2b       	or	r25, r17
   1e11e:	0e 94 f2 fc 	call	0x1f9e4	; 0x1f9e4 <isp_jump_to>
        }
        // else go to BOOT LOADER
    }

//! --- Open CAN communication

    can_communication_opened = 0;   // Not opened
   1e122:	10 92 12 01 	sts	0x0112, r1

    //- Pull-up on TxCAN & RxCAN one by one to use bit-addressing
    CAN_PORT_DIR &= ~(1<<CAN_OUTPUT_PIN); CAN_PORT_OUT |=  (1<<CAN_OUTPUT_PIN);
   1e126:	55 98       	cbi	0x0a, 5	; 10
   1e128:	5d 9a       	sbi	0x0b, 5	; 11
    CAN_PORT_DIR &= ~(1<<CAN_INPUT_PIN) ; CAN_PORT_OUT |=  (1<<CAN_INPUT_PIN) ;
   1e12a:	56 98       	cbi	0x0a, 6	; 10
   1e12c:	5e 9a       	sbi	0x0b, 6	; 11

#if (USE_UART == BOTH_UART)
    //- "uart_drv.h" macro-functions are not used to save some bytes !
             
    //- Pull-up on TxD & RxD / UART-0 one by one to use bit-addressing
    UART_0_PORT_DIR &= ~(1<<UART_0_OUTPUT_PIN); UART_0_PORT_OUT |= (1<<UART_0_OUTPUT_PIN);
   1e12e:	69 98       	cbi	0x0d, 1	; 13
   1e130:	71 9a       	sbi	0x0e, 1	; 14
    UART_0_PORT_DIR &= ~(1<<UART_0_INPUT_PIN) ; UART_0_PORT_OUT |= (1<<UART_0_INPUT_PIN) ;
   1e132:	68 98       	cbi	0x0d, 0	; 13
   1e134:	70 9a       	sbi	0x0e, 0	; 14

    //- Pull-up on TxD & RxD / UART-1 one by one to use bit-addressing
    UART_1_PORT_DIR &= ~(1<<UART_1_OUTPUT_PIN); UART_1_PORT_OUT |= (1<<UART_1_OUTPUT_PIN);
   1e136:	53 98       	cbi	0x0a, 3	; 10
   1e138:	5b 9a       	sbi	0x0b, 3	; 11
    UART_1_PORT_DIR &= ~(1<<UART_1_INPUT_PIN) ; UART_1_PORT_OUT |= (1<<UART_1_INPUT_PIN) ;
   1e13a:	52 98       	cbi	0x0a, 2	; 10
   1e13c:	5a 9a       	sbi	0x0b, 2	; 11

    uart_selected = NO_UART;
   1e13e:	8e ef       	ldi	r24, 0xFE	; 254
   1e140:	80 93 34 01 	sts	0x0134, r24
   1e144:	00 e0       	ldi	r16, 0x00	; 0

#endif

#if ((USE_UART == UART_0) || (USE_UART == UART_1))

    //- Pull-up on TxD & RxD / UART
	Uart_tx_in_pu_on();
    Uart_rx_in_pu_on();

#endif

    while (1)
    {
        //- TEST OF ACTIVITY ON RXCAN ------------------------------------------
        if ((CAN_PORT_IN & (1<<CAN_INPUT_PIN)) == 0)
   1e146:	4e 99       	sbic	0x09, 6	; 9
   1e148:	34 c0       	rjmp	.+104    	; 0x1e1b2 <main+0xe0>
        {
            //- Reset CAN peripheral
    	    Can_reset();
   1e14a:	81 e0       	ldi	r24, 0x01	; 1
   1e14c:	80 93 d8 00 	sts	0x00D8, r24
    
    	    //- Set CAN Bit-timming
            if (get_conf_byte(EB) != 0xFF)
   1e150:	82 ef       	ldi	r24, 0xF2	; 242
   1e152:	9f ef       	ldi	r25, 0xFF	; 255
   1e154:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e158:	8f 3f       	cpi	r24, 0xFF	; 255
   1e15a:	99 f0       	breq	.+38     	; 0x1e182 <main+0xb0>
            {
                CANBT1 = get_conf_byte(BTC1);
   1e15c:	83 ef       	ldi	r24, 0xF3	; 243
   1e15e:	9f ef       	ldi	r25, 0xFF	; 255
   1e160:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e164:	80 93 e2 00 	sts	0x00E2, r24
                CANBT2 = get_conf_byte(BTC2);
   1e168:	84 ef       	ldi	r24, 0xF4	; 244
   1e16a:	9f ef       	ldi	r25, 0xFF	; 255
   1e16c:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e170:	80 93 e3 00 	sts	0x00E3, r24
                CANBT3 = get_conf_byte(BTC3);
   1e174:	85 ef       	ldi	r24, 0xF5	; 245
   1e176:	9f ef       	ldi	r25, 0xFF	; 255
   1e178:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e17c:	80 93 e4 00 	sts	0x00E4, r24
   1e180:	05 c0       	rjmp	.+10     	; 0x1e18c <main+0xba>
            }
            else
            //- Loop on auto-bitrate until it is performed
            {
                while ((Can_bit_timing(auto_b))==0);        // c.f. macro in "can_drv.h"
   1e182:	80 2f       	mov	r24, r16
   1e184:	0e 94 f2 f2 	call	0x1e5e4	; 0x1e5e4 <can_auto_baudrate>
   1e188:	88 23       	and	r24, r24
   1e18a:	d9 f3       	breq	.-10     	; 0x1e182 <main+0xb0>
            }
    
    	    //- Enable CAN peripheral
            can_clear_all_mob();                        // c.f. function in "can_drv.c"
   1e18c:	0e 94 91 f2 	call	0x1e522	; 0x1e522 <can_clear_all_mob>
            Can_enable();                               // c.f. macro in "can_drv.h"
   1e190:	80 91 d8 00 	lds	r24, 0x00D8
   1e194:	82 60       	ori	r24, 0x02	; 2
   1e196:	80 93 d8 00 	sts	0x00D8, r24
    
            //- Initialization of CAN ISP PROTOCOL only if CAN communication NOT opened
            if(!can_communication_opened) can_isp_protocol_init();
   1e19a:	80 91 12 01 	lds	r24, 0x0112
   1e19e:	88 23       	and	r24, r24
   1e1a0:	11 f4       	brne	.+4      	; 0x1e1a6 <main+0xd4>
   1e1a2:	0e 94 a4 f4 	call	0x1e948	; 0x1e948 <can_isp_protocol_init>
    
            //- CAN ISP PROTOCOL execution
            while(can_isp_protocol_task());
   1e1a6:	0e 94 ee f4 	call	0x1e9dc	; 0x1e9dc <can_isp_protocol_task>
   1e1aa:	88 23       	and	r24, r24
   1e1ac:	e1 f7       	brne	.-8      	; 0x1e1a6 <main+0xd4>
            //- Exit with "0" only if CAN hardware error occurs
            auto_b = ((~auto_b)&0x01);      // Flip of "auto_b" for CAN
   1e1ae:	00 95       	com	r16
   1e1b0:	01 70       	andi	r16, 0x01	; 1
            
        } // if ((CAN_PORT_IN...

        //- TEST OF ACTIVITY ON RXD UARTs --------------------------------------
        
#if (USE_UART == BOTH_UART)

    	//- "uart_drv.h" macro-functions are not used to save some bytes !
        if (((UART_0_PORT_IN & UART_0_PORT_IN & UART_0_PORT_IN & (1<<UART_0_INPUT_PIN)) >> UART_0_INPUT_PIN ) == 0) uart_selected = UART_0;
   1e1b2:	8c b1       	in	r24, 0x0c	; 12
   1e1b4:	9c b1       	in	r25, 0x0c	; 12
   1e1b6:	2c b1       	in	r18, 0x0c	; 12
   1e1b8:	89 23       	and	r24, r25
   1e1ba:	82 23       	and	r24, r18
   1e1bc:	80 fd       	sbrc	r24, 0
   1e1be:	02 c0       	rjmp	.+4      	; 0x1e1c4 <main+0xf2>
   1e1c0:	10 92 34 01 	sts	0x0134, r1
        if (((UART_1_PORT_IN & UART_1_PORT_IN & UART_1_PORT_IN & (1<<UART_1_INPUT_PIN)) >> UART_1_INPUT_PIN ) == 0) uart_selected = UART_1;
   1e1c4:	89 b1       	in	r24, 0x09	; 9
   1e1c6:	99 b1       	in	r25, 0x09	; 9
   1e1c8:	29 b1       	in	r18, 0x09	; 9
   1e1ca:	89 23       	and	r24, r25
   1e1cc:	82 23       	and	r24, r18
   1e1ce:	82 fd       	sbrc	r24, 2
   1e1d0:	04 c0       	rjmp	.+8      	; 0x1e1da <main+0x108>
   1e1d2:	81 e0       	ldi	r24, 0x01	; 1
   1e1d4:	80 93 34 01 	sts	0x0134, r24
   1e1d8:	05 c0       	rjmp	.+10     	; 0x1e1e4 <main+0x112>
        
        if (uart_selected != NO_UART)
   1e1da:	80 91 34 01 	lds	r24, 0x0134
   1e1de:	8e 3f       	cpi	r24, 0xFE	; 254
   1e1e0:	09 f4       	brne	.+2      	; 0x1e1e4 <main+0x112>
   1e1e2:	b1 cf       	rjmp	.-158    	; 0x1e146 <main+0x74>
        {                     
            //- Loop on auto-baudrate until it is performed
            while (uart_init(CONF_8BIT_NOPAR_1STOP,UART_BAUDRATE) == 0);
   1e1e4:	40 e0       	ldi	r20, 0x00	; 0
   1e1e6:	50 e0       	ldi	r21, 0x00	; 0
   1e1e8:	60 e0       	ldi	r22, 0x00	; 0
   1e1ea:	70 e0       	ldi	r23, 0x00	; 0
   1e1ec:	83 e0       	ldi	r24, 0x03	; 3
   1e1ee:	0e 94 6b fc 	call	0x1f8d6	; 0x1f8d6 <uart_init>
   1e1f2:	88 23       	and	r24, r24
   1e1f4:	b9 f3       	breq	.-18     	; 0x1e1e4 <main+0x112>
            //- UART acknowledge character
            uart_putchar('U');
   1e1f6:	85 e5       	ldi	r24, 0x55	; 85
   1e1f8:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>

            //- Initialization of UART ISP PROTOCOL
            uart_isp_protocol_init();
   1e1fc:	0e 94 d1 f9 	call	0x1f3a2	; 0x1f3a2 <uart_isp_protocol_init>
    
            //- UART ISP PROTOCOL execution
            while(uart_isp_protocol_task());
   1e200:	0e 94 64 fa 	call	0x1f4c8	; 0x1f4c8 <uart_isp_protocol_task>
   1e204:	88 23       	and	r24, r24
   1e206:	09 f4       	brne	.+2      	; 0x1e20a <main+0x138>
   1e208:	9e cf       	rjmp	.-196    	; 0x1e146 <main+0x74>
   1e20a:	fa cf       	rjmp	.-12     	; 0x1e200 <main+0x12e>

0001e20c <flash_fill_temp_buffer>:
//! @return none
//!
//------------------------------------------------------------------------------
void flash_fill_temp_buffer(U16 addr, U16 word)
{
   1e20c:	0f 93       	push	r16
      Flash_fill_temp_buffer(addr, word);
   1e20e:	0b 01       	movw	r0, r22
   1e210:	fc 01       	movw	r30, r24
   1e212:	01 e0       	ldi	r16, 0x01	; 1
   1e214:	07 bf       	out	0x37, r16	; 55
   1e216:	e8 95       	spm
   1e218:	11 24       	eor	r1, r1
      //- Wait for SPMEN flag cleared
      Flash_prog_completed;
   1e21a:	07 b6       	in	r0, 0x37	; 55
   1e21c:	00 fc       	sbrc	r0, 0
   1e21e:	fd cf       	rjmp	.-6      	; 0x1e21a <flash_fill_temp_buffer+0xe>
   1e220:	0f 91       	pop	r16
   1e222:	08 95       	ret

0001e224 <flash_page_write>:
}

//------------------------------------------------------------------------------
//  @fn flash_page_write
//!
//! This function allows to write a Flash page with the temporary Flash
//! buffer content.
//!
//! @warning: 1 - This function must be fused in the NRWW Flash section.
//!           2 - The 64K page setting must be done before (ex: setting or
//!               clearing the RAMPZ register).
//!
//! @param: page_addr   Address in the range page to write (program).
//!
//! @return none
//!
//------------------------------------------------------------------------------
void flash_page_write(U16 page_addr)
{
   1e224:	0f 93       	push	r16
      //- Verify if SPMEN flag is cleared
      Flash_prog_completed;
   1e226:	07 b6       	in	r0, 0x37	; 55
   1e228:	00 fc       	sbrc	r0, 0
   1e22a:	fd cf       	rjmp	.-6      	; 0x1e226 <flash_page_write+0x2>
      Flash_page_write(page_addr);
   1e22c:	fc 01       	movw	r30, r24
   1e22e:	05 e0       	ldi	r16, 0x05	; 5
   1e230:	07 bf       	out	0x37, r16	; 55
   1e232:	e8 95       	spm
      //- Wait for SPMEN flag cleared
      Flash_prog_completed;
   1e234:	07 b6       	in	r0, 0x37	; 55
   1e236:	00 fc       	sbrc	r0, 0
   1e238:	fd cf       	rjmp	.-6      	; 0x1e234 <flash_page_write+0x10>
   1e23a:	0f 91       	pop	r16
   1e23c:	08 95       	ret

0001e23e <flash_page_erase>:
}

//------------------------------------------------------------------------------
//  @fn flash_page_erase
//!
//! This function allows to erase a Flash page.
//!
//! @warning: 1 - This function must be fused in the NRWW Flash section.
//!           2 - The 64K page setting must be done before (ex: setting or
//!               clearing the RAMPZ register).
//!
//! @param: page_addr   Address in the range page to erase.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void flash_page_erase(U16 page_addr)
{
   1e23e:	0f 93       	push	r16
      //- Verify if SPMEN flag is cleared
      Flash_prog_completed;
   1e240:	07 b6       	in	r0, 0x37	; 55
   1e242:	00 fc       	sbrc	r0, 0
   1e244:	fd cf       	rjmp	.-6      	; 0x1e240 <flash_page_erase+0x2>
      Flash_page_erase(page_addr);
   1e246:	fc 01       	movw	r30, r24
   1e248:	03 e0       	ldi	r16, 0x03	; 3
   1e24a:	07 bf       	out	0x37, r16	; 55
   1e24c:	e8 95       	spm
      //- Wait for SPMEN flag cleared
      Flash_prog_completed;
   1e24e:	07 b6       	in	r0, 0x37	; 55
   1e250:	00 fc       	sbrc	r0, 0
   1e252:	fd cf       	rjmp	.-6      	; 0x1e24e <flash_page_erase+0x10>
   1e254:	0f 91       	pop	r16
   1e256:	08 95       	ret

0001e258 <flash_rd_byte>:
//! @return:    Value read in the Flash memory.
//!
//------------------------------------------------------------------------------
U8 flash_rd_byte(U16 addr_byte)
{
   1e258:	2b b7       	in	r18, 0x3b	; 59
#if defined(_RAMPZ_IS_USED_)
    U32  far_addr_byte;

    far_addr_byte = (((U32)(RAMPZ))<<16) | ((U32)(addr_byte));
    return (Farflash_rd_byte(far_addr_byte));
   1e25a:	33 27       	eor	r19, r19
   1e25c:	44 27       	eor	r20, r20
   1e25e:	55 27       	eor	r21, r21
   1e260:	a9 01       	movw	r20, r18
   1e262:	33 27       	eor	r19, r19
   1e264:	22 27       	eor	r18, r18
   1e266:	aa 27       	eor	r26, r26
   1e268:	bb 27       	eor	r27, r27
   1e26a:	28 2b       	or	r18, r24
   1e26c:	39 2b       	or	r19, r25
   1e26e:	4a 2b       	or	r20, r26
   1e270:	5b 2b       	or	r21, r27
   1e272:	4b bf       	out	0x3b, r20	; 59
   1e274:	f3 2f       	mov	r31, r19
   1e276:	e2 2f       	mov	r30, r18
   1e278:	d8 95       	elpm
   1e27a:	20 2d       	mov	r18, r0

#else
    return (Stdflash_rd_byte(addr_byte));

#endif   //- If _RAMPZ_IS_USED_ ...

//    return (Flash_rd_byte(addr_word));
}
   1e27c:	82 2f       	mov	r24, r18
   1e27e:	99 27       	eor	r25, r25
   1e280:	08 95       	ret

0001e282 <flash_rd_word>:

//------------------------------------------------------------------------------
//  @fn flash_rd_word
//!
//! This function allows to read a word in 64K bytes of Flash memory.
//!
//! @warning: 1 - The address of the word is an even byte address.
//!           2 - The 64K page setting must be done before (ex: setting
//!               or clearing the RAMPZ register).
//!
//! @param: addr_word   Address to read the word in Flash memory.
//!
//! @return:    Value read in the Flash memory.
//!
//------------------------------------------------------------------------------
U16 flash_rd_word(U16 addr_word)
{
   1e282:	2b b7       	in	r18, 0x3b	; 59
#if defined(_RAMPZ_IS_USED_)
    U32  far_addr_word;

    far_addr_word = (((U32)(RAMPZ))<<16) | ((U32)(addr_word));
    return (Farflash_rd_word(far_addr_word));
   1e284:	33 27       	eor	r19, r19
   1e286:	44 27       	eor	r20, r20
   1e288:	55 27       	eor	r21, r21
   1e28a:	a9 01       	movw	r20, r18
   1e28c:	33 27       	eor	r19, r19
   1e28e:	22 27       	eor	r18, r18
   1e290:	aa 27       	eor	r26, r26
   1e292:	bb 27       	eor	r27, r27
   1e294:	28 2b       	or	r18, r24
   1e296:	39 2b       	or	r19, r25
   1e298:	4a 2b       	or	r20, r26
   1e29a:	5b 2b       	or	r21, r27

#else
    return (Stdflash_rd_word(addr_word));

#endif   //- If _RAMPZ_IS_USED_ ...

//    return (Flash_rd_word(addr_word));
}
   1e29c:	4b bf       	out	0x3b, r20	; 59
   1e29e:	f3 2f       	mov	r31, r19
   1e2a0:	e2 2f       	mov	r30, r18
   1e2a2:	d8 95       	elpm
   1e2a4:	80 2d       	mov	r24, r0
   1e2a6:	0b b6       	in	r0, 0x3b	; 59
   1e2a8:	31 96       	adiw	r30, 0x01	; 1
   1e2aa:	01 1c       	adc	r0, r1
   1e2ac:	0b be       	out	0x3b, r0	; 59
   1e2ae:	d8 95       	elpm
   1e2b0:	90 2d       	mov	r25, r0
   1e2b2:	08 95       	ret

0001e2b4 <flash_page_blank_check>:

//------------------------------------------------------------------------------
//  @fn flash_wr_byte
//!
//! This function allows to write a byte in 64K bytes of Flash memory.
//!
//! @warning: The 64K page setting must be done before (ex: setting
//!           or clearing the RAMPZ register).
//!
//! @param: addr_byte   Address to write the byte in Flash memory.
//!         value       Value to write in the Flash memory.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void flash_wr_byte(U16 addr_byte, U8 value)
{
    flash_wr_block(&value, addr_byte, 1);
}

//------------------------------------------------------------------------------
//  @fn flash_wr_block
//!
//! This function allows to write up to 65535 bytes (64K Bytes-1 byte) in
//! the Flash memory.
//! This function manages alignment issue (byte and page alignments).
//!
//!---------------------------------------------------------------------------..
//! CARE: Bytes to program must be in a different page that flash_wr_block()  ||
//!       function which is dedicated to program them.                        ||
//!       The cause is to program some bytes the following steps are needed:  ||
//!       - Fill_Temporary_Buffer (size=1 page length)                        ||
//!       - Erase_Page                                                        ||
//!       - Program_Page                                                      ||
//!       If the bytes to program are in the page of the function, the step:  ||
//!       Erase_Page --> Program_page is disturbed because blank words are    ||
//!       fetched in place of Program_Page !!!                                ||
//!---------------------------------------------------------------------------''
//!
//! @warning: 1 - This function isn't able to address the fully 64K bytes
//!               but we cannot find in the device a source buffer up to
//!               64K bytes.
//!           2 - The 64K page setting must be done before (ex: setting
//!               or clearing the RAMPZ register).
//!
//! @param: - src      Source of (SRAM) buffer Address.
//!         - dest     Destination, start address in Flash memory where data
//!                    must be written.
//!         - byte_nb  Number of byte to write.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void flash_wr_block(U8* src, U16 dest, U16 byte_nb)
{
U8      save_i_flag;
U16     u16_temp, nb_word;
U16     address;
U16     save_page_addr;

    //--- Special for API's ------------------------
    //- First of all, disabling the Global Interrupt
    save_i_flag = SREG;
    Disable_interrupt();

    //- Compute the start address of the destination page
    address = dest & ~( (U16)(FLASH_PAGE_SIZE-1) );

    //- While there is data to load from source buffer
    while(byte_nb)
    {
        //- Save the page address
        save_page_addr = address;
        //- For each word in this page
        for(nb_word = 0; nb_word < (FLASH_PAGE_SIZE/2); nb_word++)
        {
             //- Reset data word to write
             u16_temp = 0x00;

             //- Still some data to load from source
             if(byte_nb)
             {
                //- Current address is inside the target range address
                if(address >= dest)
                {
                    //- Load MSB of word from buffer source
                    u16_temp |= (U16)(Sram_rd_byte(src));      // Sram_rd_byte(addr) defined in "flash_boot_drv.h"
                    src++; byte_nb--;
                    //- Still (encore) some data to load ?
                    if(byte_nb)
                    {
                        //- Load LSB of word from buffer source
                        u16_temp |= ((U16)(Sram_rd_byte(src))) << 8;  // Sram_rd_byte(addr) defined in "flash_boot_drv.h"
                        src++; byte_nb--;
                    }
                    //- Only the MSB of the working belong to source buffer
                    else
                    {
                        //- Load LSB form existing Flash
                        u16_temp |= ((U16)(flash_rd_byte(address+1))) << 8;
                    }
                }
                //- Current word address out of destination target
                else
                {
                    //- Load MSB from existing Flash
                    u16_temp |= (U16)(flash_rd_byte(address));
                    //- Is LSB word addr in destination range ?
                    if((address+1) == dest)
                    {
                        u16_temp |= ((U16)(Sram_rd_byte(src))) << 8;      // Sram_rd_byte(addr) defined in "flash_boot_drv.h"
                        src++; byte_nb--;
                    }
                    //- LSB read from existing Flash
                    else
                    {
                        u16_temp |= ((U16)(flash_rd_byte(address+1))) << 8;
                    }
                }
            }
            //- Complete the page with words from the Flash content
            else
            {
                u16_temp = flash_rd_word(address);
            }
            flash_fill_temp_buffer(address, u16_temp);
            address += 2;
        }

        //- If the page isn't blank then erase it
        //- It is faster than to systematically erase the page
        address = save_page_addr;
        if ( flash_page_blank_check(save_page_addr) != 0 ) flash_page_erase(save_page_addr);

        //- Write (or program) the page
        flash_page_write(save_page_addr);

        //- First Flash address update for the next page
        address = save_page_addr + FLASH_PAGE_SIZE;

    }
    //- Wait for RWWSB & SPMEN flags cleared
    Flash_rww_section_enable;
    Flash_prog_completed;

    //--- Special for API's ---------------------------
    //- If it was set, re-enabling the Global Interrupt
    if(save_i_flag & 0x80) Enable_interrupt();;

}

//------------------------------------------------------------------------------
//  @fn flash_full_erase
//!
//! This function erases the whole Flash memory. It manages itself the RAMPZ.
//!
//! @warning none
//!
//! @param none
//!
//! @return none
//!
//------------------------------------------------------------------------------
void flash_full_erase(void)

#if defined(_RAMPZ_IS_USED_)
{
U8  save_rampz;
U32 page_nb = 0;

    //- Push RAMPZ
    save_rampz = RAMPZ;

    while ( page_nb < ((U32)(MAX_FLASH_SIZE_TO_ERASE)) )
    {
        RAMPZ = ((U8)(page_nb>>16));
        flash_page_erase((U16)(page_nb));
        page_nb += ((U32)(FLASH_PAGE_SIZE));
    }
    //- Wait for RWWSB flag cleared
//    Flash_prog_completed;

    //- Pop RAMPZ
    RAMPZ = save_rampz;
}

#else
{
U16 page_nb = 0;

    while ( page_nb < ((U16)(MAX_FLASH_SIZE_TO_ERASE)) )
    {
        flash_page_erase(page_nb);
        page_nb += ((U16)(FLASH_PAGE_SIZE));
    }
}

#endif

//------------------------------------------------------------------------------
//  @fn flash_page_blank_check
//!
//! This function blank checks a page of Flash memory.
//!
//! @warning: The 64K page setting must be done before (ex: setting or
//!           clearing the RAMPZ register).
//!
//! @param: page_addr   Address in the range page to blank check.
//!
//! @return: 1 - 0000 0000 0000 0000 binary = blank page
//!          2 - 1xxx xxxx xxxx xxxx binaty = first byte address not blank
//!                                           in the page (offset in the page)
//!
//------------------------------------------------------------------------------
U16 flash_page_blank_check(U16 page_addr)
{
   1e2b4:	cf 93       	push	r28
   1e2b6:	df 93       	push	r29
U16     u16_temp = 0;
U16     nb_word;

    //- Align the page address
    page_addr = page_addr & ~((U16)(FLASH_PAGE_SIZE - 1));
   1e2b8:	bc 01       	movw	r22, r24
   1e2ba:	60 70       	andi	r22, 0x00	; 0
   1e2bc:	c0 e0       	ldi	r28, 0x00	; 0
   1e2be:	d0 e0       	ldi	r29, 0x00	; 0
   1e2c0:	8b b7       	in	r24, 0x3b	; 59
   1e2c2:	99 27       	eor	r25, r25
   1e2c4:	aa 27       	eor	r26, r26
   1e2c6:	bb 27       	eor	r27, r27
   1e2c8:	dc 01       	movw	r26, r24
   1e2ca:	99 27       	eor	r25, r25
   1e2cc:	88 27       	eor	r24, r24
   1e2ce:	9b 01       	movw	r18, r22
   1e2d0:	44 27       	eor	r20, r20
   1e2d2:	55 27       	eor	r21, r21
   1e2d4:	82 2b       	or	r24, r18
   1e2d6:	93 2b       	or	r25, r19
   1e2d8:	a4 2b       	or	r26, r20
   1e2da:	b5 2b       	or	r27, r21
   1e2dc:	ab bf       	out	0x3b, r26	; 59
   1e2de:	f9 2f       	mov	r31, r25
   1e2e0:	e8 2f       	mov	r30, r24
   1e2e2:	d8 95       	elpm
   1e2e4:	80 2d       	mov	r24, r0
   1e2e6:	0b b6       	in	r0, 0x3b	; 59
   1e2e8:	31 96       	adiw	r30, 0x01	; 1
   1e2ea:	01 1c       	adc	r0, r1
   1e2ec:	0b be       	out	0x3b, r0	; 59
   1e2ee:	d8 95       	elpm
   1e2f0:	90 2d       	mov	r25, r0

    //- Blank checking
    for(nb_word = 0; nb_word < (FLASH_PAGE_SIZE/2); nb_word++)
    {
        if( ( flash_rd_word(page_addr) ) != ((U16)(FLASH_BLANK_WORD)) )
   1e2f2:	8f 5f       	subi	r24, 0xFF	; 255
   1e2f4:	9f 4f       	sbci	r25, 0xFF	; 255
   1e2f6:	19 f0       	breq	.+6      	; 0x1e2fe <flash_page_blank_check+0x4a>
   1e2f8:	80 e0       	ldi	r24, 0x00	; 0
   1e2fa:	90 e1       	ldi	r25, 0x10	; 16
   1e2fc:	08 c0       	rjmp	.+16     	; 0x1e30e <flash_page_blank_check+0x5a>
        {
            u16_temp = 0x1000;
            //- Exit from blank checking (for(nb_word...)
            break;
        }
    page_addr += 2;
   1e2fe:	6e 5f       	subi	r22, 0xFE	; 254
   1e300:	7f 4f       	sbci	r23, 0xFF	; 255
   1e302:	21 96       	adiw	r28, 0x01	; 1
   1e304:	c0 38       	cpi	r28, 0x80	; 128
   1e306:	d1 05       	cpc	r29, r1
   1e308:	d9 f6       	brne	.-74     	; 0x1e2c0 <flash_page_blank_check+0xc>
   1e30a:	80 e0       	ldi	r24, 0x00	; 0
   1e30c:	90 e0       	ldi	r25, 0x00	; 0
   1e30e:	70 70       	andi	r23, 0x00	; 0
    }

    //- Reporting
    u16_temp = u16_temp |  ( page_addr & ((U16)(FLASH_PAGE_SIZE - 1)) );
    return (u16_temp);
}
   1e310:	86 2b       	or	r24, r22
   1e312:	97 2b       	or	r25, r23
   1e314:	df 91       	pop	r29
   1e316:	cf 91       	pop	r28
   1e318:	08 95       	ret

0001e31a <flash_full_erase>:
   1e31a:	df 92       	push	r13
   1e31c:	ef 92       	push	r14
   1e31e:	ff 92       	push	r15
   1e320:	0f 93       	push	r16
   1e322:	1f 93       	push	r17
   1e324:	db b6       	in	r13, 0x3b	; 59
   1e326:	ee 24       	eor	r14, r14
   1e328:	ff 24       	eor	r15, r15
   1e32a:	87 01       	movw	r16, r14
   1e32c:	c8 01       	movw	r24, r16
   1e32e:	aa 27       	eor	r26, r26
   1e330:	bb 27       	eor	r27, r27
   1e332:	8b bf       	out	0x3b, r24	; 59
   1e334:	c7 01       	movw	r24, r14
   1e336:	0e 94 1f f1 	call	0x1e23e	; 0x1e23e <flash_page_erase>
   1e33a:	80 e0       	ldi	r24, 0x00	; 0
   1e33c:	91 e0       	ldi	r25, 0x01	; 1
   1e33e:	a0 e0       	ldi	r26, 0x00	; 0
   1e340:	b0 e0       	ldi	r27, 0x00	; 0
   1e342:	e8 0e       	add	r14, r24
   1e344:	f9 1e       	adc	r15, r25
   1e346:	0a 1f       	adc	r16, r26
   1e348:	1b 1f       	adc	r17, r27
   1e34a:	90 e0       	ldi	r25, 0x00	; 0
   1e34c:	e9 16       	cp	r14, r25
   1e34e:	90 ee       	ldi	r25, 0xE0	; 224
   1e350:	f9 06       	cpc	r15, r25
   1e352:	91 e0       	ldi	r25, 0x01	; 1
   1e354:	09 07       	cpc	r16, r25
   1e356:	90 e0       	ldi	r25, 0x00	; 0
   1e358:	19 07       	cpc	r17, r25
   1e35a:	41 f7       	brne	.-48     	; 0x1e32c <flash_full_erase+0x12>
   1e35c:	db be       	out	0x3b, r13	; 59
   1e35e:	1f 91       	pop	r17
   1e360:	0f 91       	pop	r16
   1e362:	ff 90       	pop	r15
   1e364:	ef 90       	pop	r14
   1e366:	df 90       	pop	r13
   1e368:	08 95       	ret

0001e36a <flash_wr_block>:
   1e36a:	3f 92       	push	r3
   1e36c:	4f 92       	push	r4
   1e36e:	5f 92       	push	r5
   1e370:	6f 92       	push	r6
   1e372:	7f 92       	push	r7
   1e374:	8f 92       	push	r8
   1e376:	9f 92       	push	r9
   1e378:	af 92       	push	r10
   1e37a:	bf 92       	push	r11
   1e37c:	cf 92       	push	r12
   1e37e:	df 92       	push	r13
   1e380:	ef 92       	push	r14
   1e382:	ff 92       	push	r15
   1e384:	0f 93       	push	r16
   1e386:	1f 93       	push	r17
   1e388:	cf 93       	push	r28
   1e38a:	df 93       	push	r29
   1e38c:	4c 01       	movw	r8, r24
   1e38e:	2b 01       	movw	r4, r22
   1e390:	ea 01       	movw	r28, r20
   1e392:	3f b6       	in	r3, 0x3f	; 63
   1e394:	f8 94       	cli
   1e396:	8b 01       	movw	r16, r22
   1e398:	00 70       	andi	r16, 0x00	; 0
   1e39a:	82 c0       	rjmp	.+260    	; 0x1e4a0 <flash_wr_block+0x136>
   1e39c:	82 e0       	ldi	r24, 0x02	; 2
   1e39e:	90 e0       	ldi	r25, 0x00	; 0
   1e3a0:	e8 0e       	add	r14, r24
   1e3a2:	f9 1e       	adc	r15, r25
   1e3a4:	20 97       	sbiw	r28, 0x00	; 0
   1e3a6:	09 f4       	brne	.+2      	; 0x1e3aa <flash_wr_block+0x40>
   1e3a8:	46 c0       	rjmp	.+140    	; 0x1e436 <flash_wr_block+0xcc>
   1e3aa:	e4 14       	cp	r14, r4
   1e3ac:	f5 04       	cpc	r15, r5
   1e3ae:	40 f0       	brcs	.+16     	; 0x1e3c0 <flash_wr_block+0x56>
   1e3b0:	f4 01       	movw	r30, r8
   1e3b2:	81 91       	ld	r24, Z+
   1e3b4:	4f 01       	movw	r8, r30
   1e3b6:	c8 2e       	mov	r12, r24
   1e3b8:	dd 24       	eor	r13, r13
   1e3ba:	21 97       	sbiw	r28, 0x01	; 1
   1e3bc:	c9 f4       	brne	.+50     	; 0x1e3f0 <flash_wr_block+0x86>
   1e3be:	22 c0       	rjmp	.+68     	; 0x1e404 <flash_wr_block+0x9a>
   1e3c0:	8b b7       	in	r24, 0x3b	; 59
   1e3c2:	99 27       	eor	r25, r25
   1e3c4:	aa 27       	eor	r26, r26
   1e3c6:	bb 27       	eor	r27, r27
   1e3c8:	dc 01       	movw	r26, r24
   1e3ca:	99 27       	eor	r25, r25
   1e3cc:	88 27       	eor	r24, r24
   1e3ce:	97 01       	movw	r18, r14
   1e3d0:	44 27       	eor	r20, r20
   1e3d2:	55 27       	eor	r21, r21
   1e3d4:	82 2b       	or	r24, r18
   1e3d6:	93 2b       	or	r25, r19
   1e3d8:	a4 2b       	or	r26, r20
   1e3da:	b5 2b       	or	r27, r21
   1e3dc:	ab bf       	out	0x3b, r26	; 59
   1e3de:	f9 2f       	mov	r31, r25
   1e3e0:	e8 2f       	mov	r30, r24
   1e3e2:	d8 95       	elpm
   1e3e4:	80 2d       	mov	r24, r0
   1e3e6:	c8 2e       	mov	r12, r24
   1e3e8:	dd 24       	eor	r13, r13
   1e3ea:	a4 14       	cp	r10, r4
   1e3ec:	b5 04       	cpc	r11, r5
   1e3ee:	51 f4       	brne	.+20     	; 0x1e404 <flash_wr_block+0x9a>
   1e3f0:	f4 01       	movw	r30, r8
   1e3f2:	81 91       	ld	r24, Z+
   1e3f4:	4f 01       	movw	r8, r30
   1e3f6:	99 27       	eor	r25, r25
   1e3f8:	78 2f       	mov	r23, r24
   1e3fa:	66 27       	eor	r22, r22
   1e3fc:	6c 29       	or	r22, r12
   1e3fe:	7d 29       	or	r23, r13
   1e400:	21 97       	sbiw	r28, 0x01	; 1
   1e402:	32 c0       	rjmp	.+100    	; 0x1e468 <flash_wr_block+0xfe>
   1e404:	8b b7       	in	r24, 0x3b	; 59
   1e406:	99 27       	eor	r25, r25
   1e408:	aa 27       	eor	r26, r26
   1e40a:	bb 27       	eor	r27, r27
   1e40c:	dc 01       	movw	r26, r24
   1e40e:	99 27       	eor	r25, r25
   1e410:	88 27       	eor	r24, r24
   1e412:	95 01       	movw	r18, r10
   1e414:	44 27       	eor	r20, r20
   1e416:	55 27       	eor	r21, r21
   1e418:	82 2b       	or	r24, r18
   1e41a:	93 2b       	or	r25, r19
   1e41c:	a4 2b       	or	r26, r20
   1e41e:	b5 2b       	or	r27, r21
   1e420:	ab bf       	out	0x3b, r26	; 59
   1e422:	f9 2f       	mov	r31, r25
   1e424:	e8 2f       	mov	r30, r24
   1e426:	d8 95       	elpm
   1e428:	80 2d       	mov	r24, r0
   1e42a:	99 27       	eor	r25, r25
   1e42c:	78 2f       	mov	r23, r24
   1e42e:	66 27       	eor	r22, r22
   1e430:	6c 29       	or	r22, r12
   1e432:	7d 29       	or	r23, r13
   1e434:	19 c0       	rjmp	.+50     	; 0x1e468 <flash_wr_block+0xfe>
   1e436:	8b b7       	in	r24, 0x3b	; 59
   1e438:	99 27       	eor	r25, r25
   1e43a:	aa 27       	eor	r26, r26
   1e43c:	bb 27       	eor	r27, r27
   1e43e:	dc 01       	movw	r26, r24
   1e440:	99 27       	eor	r25, r25
   1e442:	88 27       	eor	r24, r24
   1e444:	97 01       	movw	r18, r14
   1e446:	44 27       	eor	r20, r20
   1e448:	55 27       	eor	r21, r21
   1e44a:	82 2b       	or	r24, r18
   1e44c:	93 2b       	or	r25, r19
   1e44e:	a4 2b       	or	r26, r20
   1e450:	b5 2b       	or	r27, r21
   1e452:	ab bf       	out	0x3b, r26	; 59
   1e454:	f9 2f       	mov	r31, r25
   1e456:	e8 2f       	mov	r30, r24
   1e458:	d8 95       	elpm
   1e45a:	60 2d       	mov	r22, r0
   1e45c:	0b b6       	in	r0, 0x3b	; 59
   1e45e:	31 96       	adiw	r30, 0x01	; 1
   1e460:	01 1c       	adc	r0, r1
   1e462:	0b be       	out	0x3b, r0	; 59
   1e464:	d8 95       	elpm
   1e466:	70 2d       	mov	r23, r0
   1e468:	c7 01       	movw	r24, r14
   1e46a:	0e 94 06 f1 	call	0x1e20c	; 0x1e20c <flash_fill_temp_buffer>
   1e46e:	08 94       	sec
   1e470:	61 1c       	adc	r6, r1
   1e472:	71 1c       	adc	r7, r1
   1e474:	82 e0       	ldi	r24, 0x02	; 2
   1e476:	90 e0       	ldi	r25, 0x00	; 0
   1e478:	a8 0e       	add	r10, r24
   1e47a:	b9 1e       	adc	r11, r25
   1e47c:	90 e8       	ldi	r25, 0x80	; 128
   1e47e:	69 16       	cp	r6, r25
   1e480:	71 04       	cpc	r7, r1
   1e482:	09 f0       	breq	.+2      	; 0x1e486 <flash_wr_block+0x11c>
   1e484:	8b cf       	rjmp	.-234    	; 0x1e39c <flash_wr_block+0x32>
   1e486:	c8 01       	movw	r24, r16
   1e488:	0e 94 5a f1 	call	0x1e2b4	; 0x1e2b4 <flash_page_blank_check>
   1e48c:	89 2b       	or	r24, r25
   1e48e:	19 f0       	breq	.+6      	; 0x1e496 <flash_wr_block+0x12c>
   1e490:	c8 01       	movw	r24, r16
   1e492:	0e 94 1f f1 	call	0x1e23e	; 0x1e23e <flash_page_erase>
   1e496:	c8 01       	movw	r24, r16
   1e498:	0e 94 12 f1 	call	0x1e224	; 0x1e224 <flash_page_write>
   1e49c:	00 50       	subi	r16, 0x00	; 0
   1e49e:	1f 4f       	sbci	r17, 0xFF	; 255
   1e4a0:	20 97       	sbiw	r28, 0x00	; 0
   1e4a2:	41 f0       	breq	.+16     	; 0x1e4b4 <flash_wr_block+0x14a>
   1e4a4:	58 01       	movw	r10, r16
   1e4a6:	08 94       	sec
   1e4a8:	a1 1c       	adc	r10, r1
   1e4aa:	b1 1c       	adc	r11, r1
   1e4ac:	78 01       	movw	r14, r16
   1e4ae:	66 24       	eor	r6, r6
   1e4b0:	77 24       	eor	r7, r7
   1e4b2:	78 cf       	rjmp	.-272    	; 0x1e3a4 <flash_wr_block+0x3a>
   1e4b4:	00 24       	eor	r0, r0
   1e4b6:	01 e1       	ldi	r16, 0x11	; 17
   1e4b8:	07 bf       	out	0x37, r16	; 55
   1e4ba:	e8 95       	spm
   1e4bc:	07 b6       	in	r0, 0x37	; 55
   1e4be:	00 fc       	sbrc	r0, 0
   1e4c0:	fd cf       	rjmp	.-6      	; 0x1e4bc <flash_wr_block+0x152>
   1e4c2:	37 fe       	sbrs	r3, 7
   1e4c4:	01 c0       	rjmp	.+2      	; 0x1e4c8 <flash_wr_block+0x15e>
   1e4c6:	78 94       	sei
   1e4c8:	df 91       	pop	r29
   1e4ca:	cf 91       	pop	r28
   1e4cc:	1f 91       	pop	r17
   1e4ce:	0f 91       	pop	r16
   1e4d0:	ff 90       	pop	r15
   1e4d2:	ef 90       	pop	r14
   1e4d4:	df 90       	pop	r13
   1e4d6:	cf 90       	pop	r12
   1e4d8:	bf 90       	pop	r11
   1e4da:	af 90       	pop	r10
   1e4dc:	9f 90       	pop	r9
   1e4de:	8f 90       	pop	r8
   1e4e0:	7f 90       	pop	r7
   1e4e2:	6f 90       	pop	r6
   1e4e4:	5f 90       	pop	r5
   1e4e6:	4f 90       	pop	r4
   1e4e8:	3f 90       	pop	r3
   1e4ea:	08 95       	ret

0001e4ec <flash_wr_byte>:
   1e4ec:	cf 93       	push	r28
   1e4ee:	df 93       	push	r29
   1e4f0:	cd b7       	in	r28, 0x3d	; 61
   1e4f2:	de b7       	in	r29, 0x3e	; 62
   1e4f4:	21 97       	sbiw	r28, 0x01	; 1
   1e4f6:	0f b6       	in	r0, 0x3f	; 63
   1e4f8:	f8 94       	cli
   1e4fa:	de bf       	out	0x3e, r29	; 62
   1e4fc:	0f be       	out	0x3f, r0	; 63
   1e4fe:	cd bf       	out	0x3d, r28	; 61
   1e500:	69 83       	std	Y+1, r22	; 0x01
   1e502:	41 e0       	ldi	r20, 0x01	; 1
   1e504:	50 e0       	ldi	r21, 0x00	; 0
   1e506:	bc 01       	movw	r22, r24
   1e508:	ce 01       	movw	r24, r28
   1e50a:	01 96       	adiw	r24, 0x01	; 1
   1e50c:	0e 94 b5 f1 	call	0x1e36a	; 0x1e36a <flash_wr_block>
   1e510:	21 96       	adiw	r28, 0x01	; 1
   1e512:	0f b6       	in	r0, 0x3f	; 63
   1e514:	f8 94       	cli
   1e516:	de bf       	out	0x3e, r29	; 62
   1e518:	0f be       	out	0x3f, r0	; 63
   1e51a:	cd bf       	out	0x3d, r28	; 61
   1e51c:	df 91       	pop	r29
   1e51e:	cf 91       	pop	r28
   1e520:	08 95       	ret

0001e522 <can_clear_all_mob>:
//!
//! @return none
//------------------------------------------------------------------------------
void can_clear_all_mob(void)
{
   1e522:	20 e0       	ldi	r18, 0x00	; 0
   1e524:	30 e0       	ldi	r19, 0x00	; 0
U8  mob_number;
/*
    U8  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
    {
        CANPAGE = (mob_number << 4);    //! Page index
   1e526:	82 2f       	mov	r24, r18
   1e528:	82 95       	swap	r24
   1e52a:	80 7f       	andi	r24, 0xF0	; 240
   1e52c:	80 93 ed 00 	sts	0x00ED, r24
   1e530:	ee ee       	ldi	r30, 0xEE	; 238
   1e532:	f0 e0       	ldi	r31, 0x00	; 0
        Can_clear_mob();                //! All MOb Registers=0
   1e534:	11 92       	st	Z+, r1
   1e536:	e8 3f       	cpi	r30, 0xF8	; 248
   1e538:	f1 05       	cpc	r31, r1
   1e53a:	e1 f7       	brne	.-8      	; 0x1e534 <can_clear_all_mob+0x12>
   1e53c:	2f 5f       	subi	r18, 0xFF	; 255
   1e53e:	3f 4f       	sbci	r19, 0xFF	; 255
   1e540:	2f 30       	cpi	r18, 0x0F	; 15
   1e542:	31 05       	cpc	r19, r1
   1e544:	81 f7       	brne	.-32     	; 0x1e526 <can_clear_all_mob+0x4>
   1e546:	08 95       	ret

0001e548 <can_get_mob_free>:
/*
        for (data_index = 0; data_index < NB_DATA_MAX; data_index++)
        {
            CANMSG = 0;                 //! MOb data FIFO
        }
*/
    }
}

//------------------------------------------------------------------------------
//  @fn can_get_mob_free
//!
//! This function returns the number of the first MOb available or 0xFF if
//! no MOb is available.
//!
//! @warning none.
//!
//! @param  none.
//!
//! @return Handle of MOb.
//!          - MOb[0] upto MOb[LAST_MOB_NB]
//!          - 0xFF if no MOb
//------------------------------------------------------------------------------
U8 can_get_mob_free(void)
{
   1e548:	40 91 ed 00 	lds	r20, 0x00ED
   1e54c:	20 e0       	ldi	r18, 0x00	; 0
   1e54e:	30 e0       	ldi	r19, 0x00	; 0
    U8 mob_number, page_saved;

    page_saved = CANPAGE;
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
    {
        Can_set_mob(mob_number);
   1e550:	82 2f       	mov	r24, r18
   1e552:	82 95       	swap	r24
   1e554:	80 7f       	andi	r24, 0xF0	; 240
   1e556:	80 93 ed 00 	sts	0x00ED, r24
        if ((CANCDMOB & 0xC0) == 0x00) //! Disable configuration
   1e55a:	80 91 ef 00 	lds	r24, 0x00EF
   1e55e:	80 7c       	andi	r24, 0xC0	; 192
   1e560:	29 f4       	brne	.+10     	; 0x1e56c <can_get_mob_free+0x24>
        {
            CANPAGE = page_saved;
   1e562:	40 93 ed 00 	sts	0x00ED, r20
            return (mob_number);
   1e566:	82 2f       	mov	r24, r18
   1e568:	99 27       	eor	r25, r25
   1e56a:	08 95       	ret
   1e56c:	2f 5f       	subi	r18, 0xFF	; 255
   1e56e:	3f 4f       	sbci	r19, 0xFF	; 255
   1e570:	2f 30       	cpi	r18, 0x0F	; 15
   1e572:	31 05       	cpc	r19, r1
   1e574:	69 f7       	brne	.-38     	; 0x1e550 <can_get_mob_free+0x8>
        }
    }
    CANPAGE = page_saved;
   1e576:	40 93 ed 00 	sts	0x00ED, r20
   1e57a:	8f ef       	ldi	r24, 0xFF	; 255
   1e57c:	90 e0       	ldi	r25, 0x00	; 0
    return (NO_MOB);
}
   1e57e:	08 95       	ret

0001e580 <can_get_mob_status>:

//------------------------------------------------------------------------------
//  @fn can_get_mob_status
//!
//! This function returns information "MOB completed its job"
//! if one of the RXOK or TXOK Flag is set or "MOB not completed its job
//! if no RXOK and TXOK flags are set.
//! Previously, this function checks if the MOb is configured or not and in
//!  case of the MOB not configured, the function returns "MOB_DISABLE".
//!
//! @warning none.
//!
//! @param none.
//!
//! @return MOb Status.
//!          -  MOB_NOT_COMPLETED
//!          -  MOB_TX_COMPLETED
//!          -  MOB_RX_COMPLETED
//!          -  MOB_RX_DLC_WARNING
//!          -  MOB_DISABLE
//!          or should be a combination of the following errors
//!          -  MOB_ACK_ERROR
//!          -  MOB_FORM_ERROR
//!          -  MOB_CRC_ERROR
//!          -  MOB_STUFF_ERROR
//!          -  MOB_BIT_ERROR
//------------------------------------------------------------------------------
U8 can_get_mob_status(void)
{
   1e580:	80 91 ef 00 	lds	r24, 0x00EF
   1e584:	80 7c       	andi	r24, 0xC0	; 192
   1e586:	19 f4       	brne	.+6      	; 0x1e58e <can_get_mob_status+0xe>
    U8 mob_status, canstmob_copy;

    // Test if MOb ENABLE or DISABLE
    if ((CANCDMOB & 0xC0) == 0x00) {return(MOB_DISABLE);}
   1e588:	8f ef       	ldi	r24, 0xFF	; 255
   1e58a:	90 e0       	ldi	r25, 0x00	; 0
   1e58c:	08 95       	ret

    canstmob_copy = CANSTMOB; // Copy for test integrity
   1e58e:	90 91 ee 00 	lds	r25, 0x00EE

    // If MOb is ENABLE, test if MOb is COMPLETED
    // - MOb Status = 0x20 then MOB_RX_COMPLETED
    // - MOb Status = 0x40 then MOB_TX_COMPLETED
    // - MOb Status = 0xA0 then MOB_RX_COMPLETED_DLCW
    mob_status = canstmob_copy & ((1<<DLCW)|(1<<TXOK)|(1<<RXOK));
   1e592:	89 2f       	mov	r24, r25
   1e594:	80 7e       	andi	r24, 0xE0	; 224
    if ( (mob_status==MOB_RX_COMPLETED) ||   \
   1e596:	80 32       	cpi	r24, 0x20	; 32
   1e598:	21 f0       	breq	.+8      	; 0x1e5a2 <can_get_mob_status+0x22>
   1e59a:	80 34       	cpi	r24, 0x40	; 64
   1e59c:	11 f0       	breq	.+4      	; 0x1e5a2 <can_get_mob_status+0x22>
   1e59e:	80 3a       	cpi	r24, 0xA0	; 160
   1e5a0:	11 f4       	brne	.+4      	; 0x1e5a6 <can_get_mob_status+0x26>
   1e5a2:	99 27       	eor	r25, r25
   1e5a4:	08 95       	ret
         (mob_status==MOB_TX_COMPLETED) ||   \
         (mob_status==MOB_RX_COMPLETED_DLCW) ) { return(mob_status); }

    // If MOb is ENABLE & NOT_COMPLETED, test if MOb is in ERROR
    // - MOb Status bit_0 = MOB_ACK_ERROR
    // - MOb Status bit_1 = MOB_FORM_ERROR
    // - MOb Status bit_2 = MOB_CRC_ERROR
    // - MOb Status bit_3 = MOB_STUFF_ERROR
    // - MOb Status bit_4 = MOB_BIT_ERROR
    mob_status = canstmob_copy & ERR_MOB_MSK;
   1e5a6:	89 2f       	mov	r24, r25
   1e5a8:	8f 71       	andi	r24, 0x1F	; 31
    if (mob_status != 0) { return(mob_status); }
   1e5aa:	19 f4       	brne	.+6      	; 0x1e5b2 <can_get_mob_status+0x32>
   1e5ac:	80 e0       	ldi	r24, 0x00	; 0
   1e5ae:	90 e0       	ldi	r25, 0x00	; 0
   1e5b0:	08 95       	ret
   1e5b2:	99 27       	eor	r25, r25

    // If CANSTMOB = 0 then MOB_NOT_COMPLETED
    return(MOB_NOT_COMPLETED);
}
   1e5b4:	08 95       	ret

0001e5b6 <can_get_data>:

//------------------------------------------------------------------------------
//  @fn can_get_data
//!
//! This function copy the data from the selected MOb to the address
//! passed as parameter.
//!
//! @warning none.
//!
//! @param CAN message data address.
//!
//! @return none.
//------------------------------------------------------------------------------
void can_get_data(U8* p_can_message_data)
{
   1e5b6:	bc 01       	movw	r22, r24
   1e5b8:	40 e0       	ldi	r20, 0x00	; 0
   1e5ba:	50 e0       	ldi	r21, 0x00	; 0
   1e5bc:	05 c0       	rjmp	.+10     	; 0x1e5c8 <can_get_data+0x12>
    U8 data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
    {
        *(p_can_message_data + data_index) = CANMSG;
   1e5be:	e6 0f       	add	r30, r22
   1e5c0:	f7 1f       	adc	r31, r23
   1e5c2:	80 91 fa 00 	lds	r24, 0x00FA
   1e5c6:	80 83       	st	Z, r24
   1e5c8:	24 2f       	mov	r18, r20
   1e5ca:	80 91 ef 00 	lds	r24, 0x00EF
   1e5ce:	4f 5f       	subi	r20, 0xFF	; 255
   1e5d0:	5f 4f       	sbci	r21, 0xFF	; 255
   1e5d2:	e2 2f       	mov	r30, r18
   1e5d4:	ff 27       	eor	r31, r31
   1e5d6:	99 27       	eor	r25, r25
   1e5d8:	8f 70       	andi	r24, 0x0F	; 15
   1e5da:	90 70       	andi	r25, 0x00	; 0
   1e5dc:	e8 17       	cp	r30, r24
   1e5de:	f9 07       	cpc	r31, r25
   1e5e0:	74 f3       	brlt	.-36     	; 0x1e5be <can_get_data+0x8>
   1e5e2:	08 95       	ret

0001e5e4 <can_auto_baudrate>:
    }
}

//------------------------------------------------------------------------------
//  @fn can_auto_baudrate
//!
//! This function programs itself the CANBTx registers if there is some
//! communication (activity) on the CAN bus.
//!
//! @warning complex function not yet implemented
//!
//! @param  Evaluation needed
//!         ==0: start the evaluation from faster baudrate
//!         ==1: (re)start an evaluation with CANBTx registers contents
//!
//! @return Baudrate Status
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed
//------------------------------------------------------------------------------
U8 can_auto_baudrate (U8 mode)
{
   1e5e4:	af 92       	push	r10
   1e5e6:	bf 92       	push	r11
   1e5e8:	cf 92       	push	r12
   1e5ea:	df 92       	push	r13
   1e5ec:	ef 92       	push	r14
   1e5ee:	ff 92       	push	r15
   1e5f0:	0f 93       	push	r16
   1e5f2:	1f 93       	push	r17
   1e5f4:	cf 93       	push	r28
   1e5f6:	df 93       	push	r29
   1e5f8:	cd b7       	in	r28, 0x3d	; 61
   1e5fa:	de b7       	in	r29, 0x3e	; 62
   1e5fc:	21 97       	sbiw	r28, 0x01	; 1
   1e5fe:	0f b6       	in	r0, 0x3f	; 63
   1e600:	f8 94       	cli
   1e602:	de bf       	out	0x3e, r29	; 62
   1e604:	0f be       	out	0x3f, r0	; 63
   1e606:	cd bf       	out	0x3d, r28	; 61
    U8  u8_temp0;                               //! Temporary variable
    U8  brp, prs, ntq, phs1, phs2;              //! Bit timing segment variables
    U8  phs1_inc;                               //! Computing needed
    U8  bt_not_found, wait_for_rx, evaluate;    //! Keys for "while()" loops
    U8  try_conf;                               //! Key for configurate CAN
    U8  ovrtim_flag=0;                          //! Timer overflow count
    U16 conf_index;                             //! Count of bit timing configuration tried
    U8  bt_performed;                           //! Return flag

    //! --- Default setting
    phs1_inc = evaluate = 0;
    bt_performed = 0;
    conf_index = 0;
    bt_not_found = 1;

    //! --- Init segment variables with MIN values if mode=0
    //!     or init segment variables with CANBTx if mode=1
    if (mode==0)
   1e608:	88 23       	and	r24, r24
   1e60a:	59 f4       	brne	.+22     	; 0x1e622 <can_auto_baudrate+0x3e>
   1e60c:	71 e0       	ldi	r23, 0x01	; 1
   1e60e:	e7 2e       	mov	r14, r23
   1e610:	63 e0       	ldi	r22, 0x03	; 3
   1e612:	18 e0       	ldi	r17, 0x08	; 8
   1e614:	a2 e0       	ldi	r26, 0x02	; 2
   1e616:	b2 e0       	ldi	r27, 0x02	; 2
   1e618:	70 e0       	ldi	r23, 0x00	; 0
   1e61a:	51 e0       	ldi	r21, 0x01	; 1
   1e61c:	40 e0       	ldi	r20, 0x00	; 0
   1e61e:	01 e0       	ldi	r16, 0x01	; 1
   1e620:	56 c0       	rjmp	.+172    	; 0x1e6ce <can_auto_baudrate+0xea>
    {
        brp  = BRP_MIN;
        ntq  = NTQ_MIN;
        phs1 = PHS1_MIN;
        phs2 = PHS2_MIN;
        prs  = ntq - ( phs1 + phs2 + 1 );
        try_conf = 1;       //! Try this configuration
        wait_for_rx = 1;    //! Enable "while (wait_for_rx ..." loop
    }
    else //! mode = 1
    {
        brp  = Max ((((CANBT1 &  BRP_MSK) >> 1) +1) , BRP_MIN );
   1e622:	80 91 e2 00 	lds	r24, 0x00E2
   1e626:	8e 77       	andi	r24, 0x7E	; 126
   1e628:	19 f4       	brne	.+6      	; 0x1e630 <can_auto_baudrate+0x4c>
   1e62a:	61 e0       	ldi	r22, 0x01	; 1
   1e62c:	e6 2e       	mov	r14, r22
   1e62e:	09 c0       	rjmp	.+18     	; 0x1e642 <can_auto_baudrate+0x5e>
   1e630:	80 91 e2 00 	lds	r24, 0x00E2
   1e634:	99 27       	eor	r25, r25
   1e636:	8e 77       	andi	r24, 0x7E	; 126
   1e638:	90 70       	andi	r25, 0x00	; 0
   1e63a:	95 95       	asr	r25
   1e63c:	87 95       	ror	r24
   1e63e:	e8 2e       	mov	r14, r24
   1e640:	e3 94       	inc	r14
        prs  = Max ((((CANBT2 &  PRS_MSK) >> 1) +1) , PRS_MIN );
   1e642:	80 91 e3 00 	lds	r24, 0x00E3
   1e646:	8e 70       	andi	r24, 0x0E	; 14
   1e648:	11 f4       	brne	.+4      	; 0x1e64e <can_auto_baudrate+0x6a>
   1e64a:	61 e0       	ldi	r22, 0x01	; 1
   1e64c:	09 c0       	rjmp	.+18     	; 0x1e660 <can_auto_baudrate+0x7c>
   1e64e:	80 91 e3 00 	lds	r24, 0x00E3
   1e652:	99 27       	eor	r25, r25
   1e654:	8e 70       	andi	r24, 0x0E	; 14
   1e656:	90 70       	andi	r25, 0x00	; 0
   1e658:	95 95       	asr	r25
   1e65a:	87 95       	ror	r24
   1e65c:	68 2f       	mov	r22, r24
   1e65e:	6f 5f       	subi	r22, 0xFF	; 255
        phs1 = Max ((((CANBT3 & PHS1_MSK) >> 1) +1) , PHS1_MIN);
   1e660:	80 91 e4 00 	lds	r24, 0x00E4
   1e664:	8e 70       	andi	r24, 0x0E	; 14
   1e666:	83 30       	cpi	r24, 0x03	; 3
   1e668:	10 f4       	brcc	.+4      	; 0x1e66e <can_auto_baudrate+0x8a>
   1e66a:	a2 e0       	ldi	r26, 0x02	; 2
   1e66c:	09 c0       	rjmp	.+18     	; 0x1e680 <can_auto_baudrate+0x9c>
   1e66e:	80 91 e4 00 	lds	r24, 0x00E4
   1e672:	99 27       	eor	r25, r25
   1e674:	8e 70       	andi	r24, 0x0E	; 14
   1e676:	90 70       	andi	r25, 0x00	; 0
   1e678:	95 95       	asr	r25
   1e67a:	87 95       	ror	r24
   1e67c:	a8 2f       	mov	r26, r24
   1e67e:	af 5f       	subi	r26, 0xFF	; 255
        phs2 = Max ((((CANBT3 & PHS2_MSK) >> 4) +1) , PHS2_MIN);
   1e680:	80 91 e4 00 	lds	r24, 0x00E4
   1e684:	80 77       	andi	r24, 0x70	; 112
   1e686:	81 31       	cpi	r24, 0x11	; 17
   1e688:	10 f4       	brcc	.+4      	; 0x1e68e <can_auto_baudrate+0xaa>
   1e68a:	b2 e0       	ldi	r27, 0x02	; 2
   1e68c:	0c c0       	rjmp	.+24     	; 0x1e6a6 <can_auto_baudrate+0xc2>
   1e68e:	80 91 e4 00 	lds	r24, 0x00E4
   1e692:	99 27       	eor	r25, r25
   1e694:	80 77       	andi	r24, 0x70	; 112
   1e696:	90 70       	andi	r25, 0x00	; 0
   1e698:	24 e0       	ldi	r18, 0x04	; 4
   1e69a:	95 95       	asr	r25
   1e69c:	87 95       	ror	r24
   1e69e:	2a 95       	dec	r18
   1e6a0:	e1 f7       	brne	.-8      	; 0x1e69a <can_auto_baudrate+0xb6>
   1e6a2:	b8 2f       	mov	r27, r24
   1e6a4:	bf 5f       	subi	r27, 0xFF	; 255
        ntq  = Max ((prs + phs1 + phs2 + 1) , NTQ_MIN);
   1e6a6:	2b 2f       	mov	r18, r27
   1e6a8:	2a 0f       	add	r18, r26
   1e6aa:	31 2d       	mov	r19, r1
   1e6ac:	31 1d       	adc	r19, r1
   1e6ae:	c9 01       	movw	r24, r18
   1e6b0:	86 0f       	add	r24, r22
   1e6b2:	91 1d       	adc	r25, r1
   1e6b4:	08 97       	sbiw	r24, 0x08	; 8
   1e6b6:	14 f4       	brge	.+4      	; 0x1e6bc <can_auto_baudrate+0xd8>
   1e6b8:	18 e0       	ldi	r17, 0x08	; 8
   1e6ba:	05 c0       	rjmp	.+10     	; 0x1e6c6 <can_auto_baudrate+0xe2>
   1e6bc:	1b 2f       	mov	r17, r27
   1e6be:	1a 0f       	add	r17, r26
   1e6c0:	6f 5f       	subi	r22, 0xFF	; 255
   1e6c2:	16 0f       	add	r17, r22
   1e6c4:	61 50       	subi	r22, 0x01	; 1
   1e6c6:	71 e0       	ldi	r23, 0x01	; 1
   1e6c8:	50 e0       	ldi	r21, 0x00	; 0
   1e6ca:	41 e0       	ldi	r20, 0x01	; 1
   1e6cc:	00 e0       	ldi	r16, 0x00	; 0
   1e6ce:	20 e0       	ldi	r18, 0x00	; 0
   1e6d0:	30 e0       	ldi	r19, 0x00	; 0
        phs1_inc = evaluate = 1;   //! To enter in "while (evaluate ..." loop
        try_conf = 0;       //! Look for the next configuration
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
    {
        Can_set_mob(u8_temp0);  //! Page index
   1e6d2:	82 2f       	mov	r24, r18
   1e6d4:	82 95       	swap	r24
   1e6d6:	80 7f       	andi	r24, 0xF0	; 240
   1e6d8:	80 93 ed 00 	sts	0x00ED, r24
   1e6dc:	ee ee       	ldi	r30, 0xEE	; 238
   1e6de:	f0 e0       	ldi	r31, 0x00	; 0
        Can_clear_mob();        //! All MOb Registers = 0x00
   1e6e0:	11 92       	st	Z+, r1
   1e6e2:	e8 3f       	cpi	r30, 0xF8	; 248
   1e6e4:	f1 05       	cpc	r31, r1
   1e6e6:	e1 f7       	brne	.-8      	; 0x1e6e0 <can_auto_baudrate+0xfc>
   1e6e8:	2f 5f       	subi	r18, 0xFF	; 255
   1e6ea:	3f 4f       	sbci	r19, 0xFF	; 255
   1e6ec:	2f 30       	cpi	r18, 0x0F	; 15
   1e6ee:	31 05       	cpc	r19, r1
   1e6f0:	81 f7       	brne	.-32     	; 0x1e6d2 <can_auto_baudrate+0xee>
   1e6f2:	ff 24       	eor	r15, r15
   1e6f4:	aa 24       	eor	r10, r10
   1e6f6:	bb 24       	eor	r11, r11
   1e6f8:	dd 24       	eor	r13, r13
   1e6fa:	ce 2c       	mov	r12, r14
   1e6fc:	cc 0c       	add	r12, r12
   1e6fe:	3e ef       	ldi	r19, 0xFE	; 254
   1e700:	c3 0e       	add	r12, r19
    }

    while (bt_not_found == 1)
    {
        if (try_conf == 1)
   1e702:	01 30       	cpi	r16, 0x01	; 1
   1e704:	19 f0       	breq	.+6      	; 0x1e70c <can_auto_baudrate+0x128>
   1e706:	81 e0       	ldi	r24, 0x01	; 1
   1e708:	89 83       	std	Y+1, r24	; 0x01
   1e70a:	81 c0       	rjmp	.+258    	; 0x1e80e <can_auto_baudrate+0x22a>
        {
            Can_reset();
   1e70c:	00 93 d8 00 	sts	0x00D8, r16
            conf_index++;
   1e710:	08 94       	sec
   1e712:	a1 1c       	adc	r10, r1
   1e714:	b1 1c       	adc	r11, r1
            ovrtim_flag=0;

            //! --- CANBTx registers update (sjw = phs2/2, 3 sample points)
            CANBT1 = ((brp-1) << BRP);
   1e716:	c0 92 e2 00 	sts	0x00E2, r12
            CANBT2 = (((phs2 >> 1)-1) << SJW) |((prs-1) << PRS);
   1e71a:	2b 2f       	mov	r18, r27
   1e71c:	26 95       	lsr	r18
   1e71e:	33 27       	eor	r19, r19
   1e720:	21 50       	subi	r18, 0x01	; 1
   1e722:	30 40       	sbci	r19, 0x00	; 0
   1e724:	85 e0       	ldi	r24, 0x05	; 5
   1e726:	22 0f       	add	r18, r18
   1e728:	33 1f       	adc	r19, r19
   1e72a:	8a 95       	dec	r24
   1e72c:	e1 f7       	brne	.-8      	; 0x1e726 <can_auto_baudrate+0x142>
   1e72e:	86 2f       	mov	r24, r22
   1e730:	99 27       	eor	r25, r25
   1e732:	01 97       	sbiw	r24, 0x01	; 1
   1e734:	88 0f       	add	r24, r24
   1e736:	99 1f       	adc	r25, r25
   1e738:	28 2b       	or	r18, r24
   1e73a:	20 93 e3 00 	sts	0x00E3, r18
            CANBT3 = (((phs2-1) << PHS2) | ((phs1-1) << PHS1) | (1<<SMP));
   1e73e:	2a 2f       	mov	r18, r26
   1e740:	33 27       	eor	r19, r19
   1e742:	21 50       	subi	r18, 0x01	; 1
   1e744:	30 40       	sbci	r19, 0x00	; 0
   1e746:	22 0f       	add	r18, r18
   1e748:	33 1f       	adc	r19, r19
   1e74a:	8b 2f       	mov	r24, r27
   1e74c:	99 27       	eor	r25, r25
   1e74e:	01 97       	sbiw	r24, 0x01	; 1
   1e750:	34 e0       	ldi	r19, 0x04	; 4
   1e752:	88 0f       	add	r24, r24
   1e754:	99 1f       	adc	r25, r25
   1e756:	3a 95       	dec	r19
   1e758:	e1 f7       	brne	.-8      	; 0x1e752 <can_auto_baudrate+0x16e>
   1e75a:	81 60       	ori	r24, 0x01	; 1
   1e75c:	82 2b       	or	r24, r18
   1e75e:	80 93 e4 00 	sts	0x00E4, r24

            //! --- Set CAN-Timer - Used for time-out
            //!     There are 641 (0x281) possible evaluations. The first one provides the faster
            //!         the faster bit timing, the last one gives the slower. It is necessary to
            //!         modulate the time-out versus bit timing (0x281>>3=0x50, matching an U8).
            CANTCON = (U8)(conf_index >> 3);
   1e762:	c5 01       	movw	r24, r10
   1e764:	23 e0       	ldi	r18, 0x03	; 3
   1e766:	96 95       	lsr	r25
   1e768:	87 95       	ror	r24
   1e76a:	2a 95       	dec	r18
   1e76c:	e1 f7       	brne	.-8      	; 0x1e766 <can_auto_baudrate+0x182>
   1e76e:	80 93 e5 00 	sts	0x00E5, r24

            //! --- MOb configuration
            Can_set_mob(MOB_0);                 //! Use MOb-0
   1e772:	10 92 ed 00 	sts	0x00ED, r1
            CANSTMOB = 0;                       //! Reset MOb status (undone by "Can_reset()")
   1e776:	10 92 ee 00 	sts	0x00EE, r1
            CANCDMOB = (MOB_Rx_ENA  << CONMOB); //! MOb 0 in receive mode
   1e77a:	80 e8       	ldi	r24, 0x80	; 128
   1e77c:	80 93 ef 00 	sts	0x00EF, r24

            //! CAN controller configuration
            CANGCON = (1<<LISTEN) | (1<<ENASTB);//! Enable CAN controller in "listen" mode
   1e780:	8a e0       	ldi	r24, 0x0A	; 10
   1e782:	80 93 d8 00 	sts	0x00D8, r24
            while ((CANGSTA & (1<<ENFG)) == 0); //! Wait for Enable OK
   1e786:	80 91 d9 00 	lds	r24, 0x00D9
   1e78a:	82 ff       	sbrs	r24, 2
   1e78c:	fc cf       	rjmp	.-8      	; 0x1e786 <can_auto_baudrate+0x1a2>
            CANGIT = 0xFF;                      //! Reset General errors and OVRTIM flag
   1e78e:	8f ef       	ldi	r24, 0xFF	; 255
   1e790:	80 93 da 00 	sts	0x00DA, r24
   1e794:	ff 24       	eor	r15, r15
   1e796:	b7 cf       	rjmp	.-146    	; 0x1e706 <can_auto_baudrate+0x122>
        }

        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
        {
            u8_temp0 = CANSTMOB;
   1e798:	80 91 ee 00 	lds	r24, 0x00EE
            //! --- RxOK received ?
            if ((u8_temp0 & (1<<RXOK)) != 0)
   1e79c:	99 27       	eor	r25, r25
   1e79e:	85 ff       	sbrs	r24, 5
   1e7a0:	11 c0       	rjmp	.+34     	; 0x1e7c4 <can_auto_baudrate+0x1e0>
            {   //! --- It is the successful output of "can_auto_baudrate" function
                wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
                evaluate = 0;       //! Will skip "while (evaluate ..." loop
                bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
                bt_performed = 1;   //! Return flag = TRUE
                DISABLE_MOB;        //! Disable MOb-0
   1e7a2:	80 91 ef 00 	lds	r24, 0x00EF
   1e7a6:	8f 73       	andi	r24, 0x3F	; 63
   1e7a8:	80 93 ef 00 	sts	0x00EF, r24
                CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
   1e7ac:	10 92 d8 00 	sts	0x00D8, r1
                while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
   1e7b0:	80 91 d9 00 	lds	r24, 0x00D9
   1e7b4:	82 fd       	sbrc	r24, 2
   1e7b6:	fc cf       	rjmp	.-8      	; 0x1e7b0 <can_auto_baudrate+0x1cc>
   1e7b8:	19 82       	std	Y+1, r1	; 0x01
   1e7ba:	50 e0       	ldi	r21, 0x00	; 0
   1e7bc:	40 e0       	ldi	r20, 0x00	; 0
   1e7be:	81 e0       	ldi	r24, 0x01	; 1
   1e7c0:	d8 2e       	mov	r13, r24
   1e7c2:	7e c0       	rjmp	.+252    	; 0x1e8c0 <can_auto_baudrate+0x2dc>
            }
             //! --- Else stop if any errors
             else
            {
                //! --- MOb error ?
                if ((u8_temp0 & ((1<<BERR)|(1<<SERR)|(1<<CERR)|(1<<FERR)|(1<<AERR))) !=0)
   1e7c4:	8f 71       	andi	r24, 0x1F	; 31
   1e7c6:	90 70       	andi	r25, 0x00	; 0
   1e7c8:	89 2b       	or	r24, r25
   1e7ca:	11 f0       	breq	.+4      	; 0x1e7d0 <can_auto_baudrate+0x1ec>
   1e7cc:	50 e0       	ldi	r21, 0x00	; 0
   1e7ce:	41 e0       	ldi	r20, 0x01	; 1
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
                }

                u8_temp0 = CANGIT;
   1e7d0:	80 91 da 00 	lds	r24, 0x00DA

                //! --- Time_out reached ?
                if ((u8_temp0 & (1<<OVRTIM)) !=0 )
   1e7d4:	28 2f       	mov	r18, r24
   1e7d6:	33 27       	eor	r19, r19
   1e7d8:	25 ff       	sbrs	r18, 5
   1e7da:	11 c0       	rjmp	.+34     	; 0x1e7fe <can_auto_baudrate+0x21a>
                {
                    if (ovrtim_flag==0)
   1e7dc:	ff 20       	and	r15, r15
   1e7de:	41 f4       	brne	.+16     	; 0x1e7f0 <can_auto_baudrate+0x20c>
                    {
                        //! --- First Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
   1e7e0:	80 91 da 00 	lds	r24, 0x00DA
   1e7e4:	80 62       	ori	r24, 0x20	; 32
   1e7e6:	80 93 da 00 	sts	0x00DA, r24
   1e7ea:	f1 e0       	ldi	r31, 0x01	; 1
   1e7ec:	ff 2e       	mov	r15, r31
   1e7ee:	07 c0       	rjmp	.+14     	; 0x1e7fe <can_auto_baudrate+0x21a>
                        ovrtim_flag++;
                    }
                    else
                    {
                        //! --- Second Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
   1e7f0:	80 91 da 00 	lds	r24, 0x00DA
   1e7f4:	80 62       	ori	r24, 0x20	; 32
   1e7f6:	80 93 da 00 	sts	0x00DA, r24
   1e7fa:	50 e0       	ldi	r21, 0x00	; 0
   1e7fc:	41 e0       	ldi	r20, 0x01	; 1
                        evaluate = 1;           //! Will enter in "while (evaluate ..." loop
                        wait_for_rx = 0;        //! Out of "while (wait_for_rx ..." loop
                    }
                }

                //! --- General error ?
                if ((u8_temp0 & ((1<<SERG)|(1<<CERG)|(1<<FERG)|(1<<AERG))) !=0)
   1e7fe:	2f 70       	andi	r18, 0x0F	; 15
   1e800:	30 70       	andi	r19, 0x00	; 0
   1e802:	23 2b       	or	r18, r19
   1e804:	21 f0       	breq	.+8      	; 0x1e80e <can_auto_baudrate+0x22a>
   1e806:	50 e0       	ldi	r21, 0x00	; 0
   1e808:	41 e0       	ldi	r20, 0x01	; 1
   1e80a:	01 e0       	ldi	r16, 0x01	; 1
   1e80c:	59 c0       	rjmp	.+178    	; 0x1e8c0 <can_auto_baudrate+0x2dc>
   1e80e:	51 30       	cpi	r21, 0x01	; 1
   1e810:	19 f2       	breq	.-122    	; 0x1e798 <can_auto_baudrate+0x1b4>
   1e812:	56 c0       	rjmp	.+172    	; 0x1e8c0 <can_auto_baudrate+0x2dc>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
                    try_conf = 1;       //! Try this configuration
                }
            }
        } // while (wait_for_rx ...

        //! --- EVALUATE LOOP:
        //!     =============
        //!     Compute a new bit timing configuration. First, Phase 1 is increased,
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
        {
            if (phs1_inc != 0) phs1++;
   1e814:	71 11       	cpse	r23, r1
   1e816:	af 5f       	subi	r26, 0xFF	; 255
            phs1_inc = 1;

            // --- The following test takes into account the previous incrementation of phs1
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
   1e818:	a9 30       	cpi	r26, 0x09	; 9
   1e81a:	f0 f0       	brcs	.+60     	; 0x1e858 <can_auto_baudrate+0x274>
   1e81c:	b8 30       	cpi	r27, 0x08	; 8
   1e81e:	f0 f0       	brcs	.+60     	; 0x1e85c <can_auto_baudrate+0x278>
            {
                phs1 = PHS1_MIN;
                phs2 = PHS2_MIN;
                phs1_inc = 0;
                if (ntq != NTQ_MAX) ntq++;
   1e820:	19 31       	cpi	r17, 0x19	; 25
   1e822:	11 f0       	breq	.+4      	; 0x1e828 <can_auto_baudrate+0x244>
   1e824:	1f 5f       	subi	r17, 0xFF	; 255
   1e826:	07 c0       	rjmp	.+14     	; 0x1e836 <can_auto_baudrate+0x252>
                else
                {
                    ntq = NTQ_MIN;
                    if (brp != BRP_MAX) brp++;
   1e828:	e0 e4       	ldi	r30, 0x40	; 64
   1e82a:	ee 16       	cp	r14, r30
   1e82c:	41 f0       	breq	.+16     	; 0x1e83e <can_auto_baudrate+0x25a>
   1e82e:	e3 94       	inc	r14
   1e830:	f2 e0       	ldi	r31, 0x02	; 2
   1e832:	cf 0e       	add	r12, r31
   1e834:	18 e0       	ldi	r17, 0x08	; 8
   1e836:	a2 e0       	ldi	r26, 0x02	; 2
   1e838:	b2 e0       	ldi	r27, 0x02	; 2
   1e83a:	70 e0       	ldi	r23, 0x00	; 0
   1e83c:	eb cf       	rjmp	.-42     	; 0x1e814 <can_auto_baudrate+0x230>
                    else
                    {
                        //! --- It is the failing of "can_auto_baudrate" function
                        evaluate = 0;       //! Out of "while (evaluate ..." loop
                        bt_performed = 0;   //! Return flag = FALSE
                        bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
                        DISABLE_MOB;        //! Disable MOb-0
   1e83e:	80 91 ef 00 	lds	r24, 0x00EF
   1e842:	8f 73       	andi	r24, 0x3F	; 63
   1e844:	80 93 ef 00 	sts	0x00EF, r24
                        CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
   1e848:	10 92 d8 00 	sts	0x00D8, r1
                        while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
   1e84c:	80 91 d9 00 	lds	r24, 0x00D9
   1e850:	82 fd       	sbrc	r24, 2
   1e852:	fc cf       	rjmp	.-8      	; 0x1e84c <can_auto_baudrate+0x268>
   1e854:	dd 24       	eor	r13, r13
   1e856:	3b c0       	rjmp	.+118    	; 0x1e8ce <can_auto_baudrate+0x2ea>
                    }
                }
            }
            else    // if (phs1 > PHS1_MAX ...
            {
                //! --- If psh1 > 5 then phs1 =phs2 or =phs2+1, else phs1=phs2
                if (phs1>5)
   1e858:	a6 30       	cpi	r26, 0x06	; 6
   1e85a:	50 f0       	brcs	.+20     	; 0x1e870 <can_auto_baudrate+0x28c>
                {
                    if (phs1>(phs2+1)) phs1=(++phs2);
   1e85c:	2a 2f       	mov	r18, r26
   1e85e:	33 27       	eor	r19, r19
   1e860:	8b 2f       	mov	r24, r27
   1e862:	99 27       	eor	r25, r25
   1e864:	01 96       	adiw	r24, 0x01	; 1
   1e866:	82 17       	cp	r24, r18
   1e868:	93 07       	cpc	r25, r19
   1e86a:	1c f4       	brge	.+6      	; 0x1e872 <can_auto_baudrate+0x28e>
   1e86c:	ab 2f       	mov	r26, r27
   1e86e:	af 5f       	subi	r26, 0xFF	; 255
   1e870:	ba 2f       	mov	r27, r26
                }
                else
                {
                phs2=phs1;
                }
                prs = ntq - ( phs1 + phs2 + 1 );
   1e872:	8a 2f       	mov	r24, r26
   1e874:	8b 0f       	add	r24, r27
   1e876:	61 2f       	mov	r22, r17
   1e878:	68 1b       	sub	r22, r24
   1e87a:	61 50       	subi	r22, 0x01	; 1

                //! --- Test PRS limits
                if ((prs <= PRS_MAX) && (prs >= PRS_MIN))
   1e87c:	86 2f       	mov	r24, r22
   1e87e:	81 50       	subi	r24, 0x01	; 1
   1e880:	88 30       	cpi	r24, 0x08	; 8
   1e882:	e0 f4       	brcc	.+56     	; 0x1e8bc <can_auto_baudrate+0x2d8>
                {
                    //! --- Values  accepted if  80% >= sampling point >= 75%
                    if (((phs2<<2) >= (1+prs+phs1)) && ((phs2+phs2+phs2) <= (1+prs+phs1)))
   1e884:	4b 2f       	mov	r20, r27
   1e886:	55 27       	eor	r21, r21
   1e888:	2a 2f       	mov	r18, r26
   1e88a:	33 27       	eor	r19, r19
   1e88c:	2f 5f       	subi	r18, 0xFF	; 255
   1e88e:	3f 4f       	sbci	r19, 0xFF	; 255
   1e890:	26 0f       	add	r18, r22
   1e892:	31 1d       	adc	r19, r1
   1e894:	ca 01       	movw	r24, r20
   1e896:	88 0f       	add	r24, r24
   1e898:	99 1f       	adc	r25, r25
   1e89a:	88 0f       	add	r24, r24
   1e89c:	99 1f       	adc	r25, r25
   1e89e:	82 17       	cp	r24, r18
   1e8a0:	93 07       	cpc	r25, r19
   1e8a2:	64 f0       	brlt	.+24     	; 0x1e8bc <can_auto_baudrate+0x2d8>
   1e8a4:	ca 01       	movw	r24, r20
   1e8a6:	88 0f       	add	r24, r24
   1e8a8:	99 1f       	adc	r25, r25
   1e8aa:	48 0f       	add	r20, r24
   1e8ac:	59 1f       	adc	r21, r25
   1e8ae:	24 17       	cp	r18, r20
   1e8b0:	35 07       	cpc	r19, r21
   1e8b2:	24 f0       	brlt	.+8      	; 0x1e8bc <can_auto_baudrate+0x2d8>
   1e8b4:	71 e0       	ldi	r23, 0x01	; 1
   1e8b6:	51 e0       	ldi	r21, 0x01	; 1
   1e8b8:	40 e0       	ldi	r20, 0x00	; 0
   1e8ba:	05 c0       	rjmp	.+10     	; 0x1e8c6 <can_auto_baudrate+0x2e2>
   1e8bc:	71 e0       	ldi	r23, 0x01	; 1
   1e8be:	aa cf       	rjmp	.-172    	; 0x1e814 <can_auto_baudrate+0x230>
   1e8c0:	41 30       	cpi	r20, 0x01	; 1
   1e8c2:	09 f4       	brne	.+2      	; 0x1e8c6 <can_auto_baudrate+0x2e2>
   1e8c4:	a7 cf       	rjmp	.-178    	; 0x1e814 <can_auto_baudrate+0x230>
   1e8c6:	29 81       	ldd	r18, Y+1	; 0x01
   1e8c8:	21 30       	cpi	r18, 0x01	; 1
   1e8ca:	09 f4       	brne	.+2      	; 0x1e8ce <can_auto_baudrate+0x2ea>
   1e8cc:	1a cf       	rjmp	.-460    	; 0x1e702 <can_auto_baudrate+0x11e>
                    {
                        evaluate = 0;     //! Out of "while (evaluate ..." loop &
                        wait_for_rx = 1;  //!    new "while (bt_not_found ..." loop
                    }
                }
            }
        } // while (evaluate ...
    } // while (bt_not_found ...

    return (bt_performed);
}
   1e8ce:	8d 2d       	mov	r24, r13
   1e8d0:	99 27       	eor	r25, r25
   1e8d2:	21 96       	adiw	r28, 0x01	; 1
   1e8d4:	0f b6       	in	r0, 0x3f	; 63
   1e8d6:	f8 94       	cli
   1e8d8:	de bf       	out	0x3e, r29	; 62
   1e8da:	0f be       	out	0x3f, r0	; 63
   1e8dc:	cd bf       	out	0x3d, r28	; 61
   1e8de:	df 91       	pop	r29
   1e8e0:	cf 91       	pop	r28
   1e8e2:	1f 91       	pop	r17
   1e8e4:	0f 91       	pop	r16
   1e8e6:	ff 90       	pop	r15
   1e8e8:	ef 90       	pop	r14
   1e8ea:	df 90       	pop	r13
   1e8ec:	cf 90       	pop	r12
   1e8ee:	bf 90       	pop	r11
   1e8f0:	af 90       	pop	r10
   1e8f2:	08 95       	ret

0001e8f4 <can_fixed_baudrate>:

//------------------------------------------------------------------------------
//  @fn can_fixed_baudrate
//!
//! This function programs the CANBTx registers with the predefined values
//! CONF_CANBT1, CONF_CANBT2, CONF_CANBT3.
//!
//! @warning
//!
//! @param (unused!)
//!
//! @return Baudrate Status
//!         fixed = 1: baudrate performed
//------------------------------------------------------------------------------
U8 can_fixed_baudrate(U8 mode)
{
   1e8f4:	81 e0       	ldi	r24, 0x01	; 1
   1e8f6:	80 93 d8 00 	sts	0x00D8, r24
    Can_reset();
    Can_conf_bt();
   1e8fa:	10 92 e2 00 	sts	0x00E2, r1
   1e8fe:	10 92 e3 00 	sts	0x00E3, r1
   1e902:	10 92 e4 00 	sts	0x00E4, r1
    return 1;
}
   1e906:	81 e0       	ldi	r24, 0x01	; 1
   1e908:	90 e0       	ldi	r25, 0x00	; 0
   1e90a:	08 95       	ret

0001e90c <can_isp_send_frame>:
//! @return
//!
//------------------------------------------------------------------------------
void can_isp_send_frame(void)
{
   1e90c:	80 e2       	ldi	r24, 0x20	; 32
   1e90e:	91 e0       	ldi	r25, 0x01	; 1
   1e910:	0e 94 1f f7 	call	0x1ee3e	; 0x1ee3e <can_cmd>
   1e914:	88 23       	and	r24, r24
   1e916:	d1 f7       	brne	.-12     	; 0x1e90c <can_isp_send_frame>
    //- Tx Command
    while(can_cmd(&can_isp_tx_msg) != CAN_CMD_ACCEPTED);
    //- wait for Tx completed
    while(can_get_status(&can_isp_tx_msg) == CAN_STATUS_NOT_COMPLETED);
   1e918:	80 e2       	ldi	r24, 0x20	; 32
   1e91a:	91 e0       	ldi	r25, 0x01	; 1
   1e91c:	0e 94 cb f7 	call	0x1ef96	; 0x1ef96 <can_get_status>
   1e920:	81 30       	cpi	r24, 0x01	; 1
   1e922:	d1 f3       	breq	.-12     	; 0x1e918 <can_isp_send_frame+0xc>
   1e924:	08 95       	ret

0001e926 <can_isp_send_error_frame>:
   1e926:	80 91 1e 01 	lds	r24, 0x011E
   1e92a:	90 91 1f 01 	lds	r25, 0x011F
   1e92e:	06 96       	adiw	r24, 0x06	; 6
   1e930:	90 93 24 01 	sts	0x0124, r25
   1e934:	80 93 23 01 	sts	0x0123, r24
   1e938:	10 92 2c 01 	sts	0x012C, r1
   1e93c:	81 e0       	ldi	r24, 0x01	; 1
   1e93e:	80 93 27 01 	sts	0x0127, r24
   1e942:	0e 94 86 f4 	call	0x1e90c	; 0x1e90c <can_isp_send_frame>
   1e946:	08 95       	ret

0001e948 <can_isp_protocol_init>:
   1e948:	cf 93       	push	r28
   1e94a:	df 93       	push	r29
   1e94c:	10 92 56 02 	sts	0x0256, r1
   1e950:	10 92 59 02 	sts	0x0259, r1
   1e954:	10 92 53 02 	sts	0x0253, r1
   1e958:	10 92 52 02 	sts	0x0252, r1
   1e95c:	c1 e0       	ldi	r28, 0x01	; 1
   1e95e:	d0 e0       	ldi	r29, 0x00	; 0
   1e960:	d0 93 55 02 	sts	0x0255, r29
   1e964:	c0 93 54 02 	sts	0x0254, r28
   1e968:	10 92 2b 01 	sts	0x012B, r1
   1e96c:	87 ef       	ldi	r24, 0xF7	; 247
   1e96e:	9f ef       	ldi	r25, 0xFF	; 255
   1e970:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1e974:	99 27       	eor	r25, r25
   1e976:	24 e0       	ldi	r18, 0x04	; 4
   1e978:	88 0f       	add	r24, r24
   1e97a:	99 1f       	adc	r25, r25
   1e97c:	2a 95       	dec	r18
   1e97e:	e1 f7       	brne	.-8      	; 0x1e978 <can_isp_protocol_init+0x30>
   1e980:	90 93 1f 01 	sts	0x011F, r25
   1e984:	80 93 1e 01 	sts	0x011E, r24
   1e988:	81 5f       	subi	r24, 0xF1	; 241
   1e98a:	97 40       	sbci	r25, 0x07	; 7
   1e98c:	20 f0       	brcs	.+8      	; 0x1e996 <can_isp_protocol_init+0x4e>
   1e98e:	10 92 1f 01 	sts	0x011F, r1
   1e992:	10 92 1e 01 	sts	0x011E, r1
   1e996:	8a e0       	ldi	r24, 0x0A	; 10
   1e998:	91 e0       	ldi	r25, 0x01	; 1
   1e99a:	90 93 1c 01 	sts	0x011C, r25
   1e99e:	80 93 1b 01 	sts	0x011B, r24
   1e9a2:	10 92 58 02 	sts	0x0258, r1
   1e9a6:	10 92 57 02 	sts	0x0257, r1
   1e9aa:	80 ef       	ldi	r24, 0xF0	; 240
   1e9ac:	97 e0       	ldi	r25, 0x07	; 7
   1e9ae:	90 93 19 01 	sts	0x0119, r25
   1e9b2:	80 93 18 01 	sts	0x0118, r24
   1e9b6:	82 e0       	ldi	r24, 0x02	; 2
   1e9b8:	90 e0       	ldi	r25, 0x00	; 0
   1e9ba:	90 93 15 01 	sts	0x0115, r25
   1e9be:	80 93 14 01 	sts	0x0114, r24
   1e9c2:	8c e2       	ldi	r24, 0x2C	; 44
   1e9c4:	91 e0       	ldi	r25, 0x01	; 1
   1e9c6:	90 93 29 01 	sts	0x0129, r25
   1e9ca:	80 93 28 01 	sts	0x0128, r24
   1e9ce:	d0 93 22 01 	sts	0x0122, r29
   1e9d2:	c0 93 21 01 	sts	0x0121, r28
   1e9d6:	df 91       	pop	r29
   1e9d8:	cf 91       	pop	r28
   1e9da:	08 95       	ret

0001e9dc <can_isp_protocol_task>:
   1e9dc:	1f 93       	push	r17
   1e9de:	88 e0       	ldi	r24, 0x08	; 8
   1e9e0:	80 93 1a 01 	sts	0x011A, r24
   1e9e4:	80 91 1e 01 	lds	r24, 0x011E
   1e9e8:	90 91 1f 01 	lds	r25, 0x011F
   1e9ec:	90 93 17 01 	sts	0x0117, r25
   1e9f0:	80 93 16 01 	sts	0x0116, r24
   1e9f4:	83 e1       	ldi	r24, 0x13	; 19
   1e9f6:	91 e0       	ldi	r25, 0x01	; 1
   1e9f8:	0e 94 1f f7 	call	0x1ee3e	; 0x1ee3e <can_cmd>
   1e9fc:	88 23       	and	r24, r24
   1e9fe:	d1 f7       	brne	.-12     	; 0x1e9f4 <can_isp_protocol_task+0x18>
   1ea00:	83 e1       	ldi	r24, 0x13	; 19
   1ea02:	91 e0       	ldi	r25, 0x01	; 1
   1ea04:	0e 94 cb f7 	call	0x1ef96	; 0x1ef96 <can_get_status>
   1ea08:	48 2f       	mov	r20, r24
   1ea0a:	81 30       	cpi	r24, 0x01	; 1
   1ea0c:	c9 f3       	breq	.-14     	; 0x1ea00 <can_isp_protocol_task+0x24>
   1ea0e:	82 30       	cpi	r24, 0x02	; 2
   1ea10:	19 f4       	brne	.+6      	; 0x1ea18 <can_isp_protocol_task+0x3c>
   1ea12:	80 e0       	ldi	r24, 0x00	; 0
   1ea14:	90 e0       	ldi	r25, 0x00	; 0
   1ea16:	11 c2       	rjmp	.+1058   	; 0x1ee3a <can_isp_protocol_task+0x45e>
   1ea18:	20 91 1e 01 	lds	r18, 0x011E
   1ea1c:	30 91 1f 01 	lds	r19, 0x011F
   1ea20:	80 91 16 01 	lds	r24, 0x0116
   1ea24:	90 91 17 01 	lds	r25, 0x0117
   1ea28:	82 1b       	sub	r24, r18
   1ea2a:	93 0b       	sbc	r25, r19
   1ea2c:	82 30       	cpi	r24, 0x02	; 2
   1ea2e:	91 05       	cpc	r25, r1
   1ea30:	09 f4       	brne	.+2      	; 0x1ea34 <can_isp_protocol_task+0x58>
   1ea32:	b6 c0       	rjmp	.+364    	; 0x1eba0 <can_isp_protocol_task+0x1c4>
   1ea34:	83 30       	cpi	r24, 0x03	; 3
   1ea36:	91 05       	cpc	r25, r1
   1ea38:	30 f4       	brcc	.+12     	; 0x1ea46 <can_isp_protocol_task+0x6a>
   1ea3a:	00 97       	sbiw	r24, 0x00	; 0
   1ea3c:	81 f0       	breq	.+32     	; 0x1ea5e <can_isp_protocol_task+0x82>
   1ea3e:	01 97       	sbiw	r24, 0x01	; 1
   1ea40:	09 f0       	breq	.+2      	; 0x1ea44 <can_isp_protocol_task+0x68>
   1ea42:	f9 c1       	rjmp	.+1010   	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ea44:	40 c0       	rjmp	.+128    	; 0x1eac6 <can_isp_protocol_task+0xea>
   1ea46:	84 30       	cpi	r24, 0x04	; 4
   1ea48:	91 05       	cpc	r25, r1
   1ea4a:	09 f4       	brne	.+2      	; 0x1ea4e <can_isp_protocol_task+0x72>
   1ea4c:	83 c1       	rjmp	.+774    	; 0x1ed54 <can_isp_protocol_task+0x378>
   1ea4e:	84 30       	cpi	r24, 0x04	; 4
   1ea50:	91 05       	cpc	r25, r1
   1ea52:	08 f4       	brcc	.+2      	; 0x1ea56 <can_isp_protocol_task+0x7a>
   1ea54:	09 c1       	rjmp	.+530    	; 0x1ec68 <can_isp_protocol_task+0x28c>
   1ea56:	06 97       	sbiw	r24, 0x06	; 6
   1ea58:	09 f0       	breq	.+2      	; 0x1ea5c <can_isp_protocol_task+0x80>
   1ea5a:	ed c1       	rjmp	.+986    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ea5c:	bd c1       	rjmp	.+890    	; 0x1edd8 <can_isp_protocol_task+0x3fc>
   1ea5e:	10 91 0a 01 	lds	r17, 0x010A
   1ea62:	86 ef       	ldi	r24, 0xF6	; 246
   1ea64:	9f ef       	ldi	r25, 0xFF	; 255
   1ea66:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1ea6a:	18 17       	cp	r17, r24
   1ea6c:	29 f0       	breq	.+10     	; 0x1ea78 <can_isp_protocol_task+0x9c>
   1ea6e:	80 91 0a 01 	lds	r24, 0x010A
   1ea72:	8f 3f       	cpi	r24, 0xFF	; 255
   1ea74:	09 f0       	breq	.+2      	; 0x1ea78 <can_isp_protocol_task+0x9c>
   1ea76:	df c1       	rjmp	.+958    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ea78:	90 91 1a 01 	lds	r25, 0x011A
   1ea7c:	91 30       	cpi	r25, 0x01	; 1
   1ea7e:	09 f0       	breq	.+2      	; 0x1ea82 <can_isp_protocol_task+0xa6>
   1ea80:	da c1       	rjmp	.+948    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ea82:	80 91 12 01 	lds	r24, 0x0112
   1ea86:	88 23       	and	r24, r24
   1ea88:	39 f4       	brne	.+14     	; 0x1ea98 <can_isp_protocol_task+0xbc>
   1ea8a:	90 93 12 01 	sts	0x0112, r25
   1ea8e:	10 92 56 02 	sts	0x0256, r1
   1ea92:	10 92 59 02 	sts	0x0259, r1
   1ea96:	04 c0       	rjmp	.+8      	; 0x1eaa0 <can_isp_protocol_task+0xc4>
   1ea98:	10 92 12 01 	sts	0x0112, r1
   1ea9c:	10 92 2b 01 	sts	0x012B, r1
   1eaa0:	80 91 1e 01 	lds	r24, 0x011E
   1eaa4:	90 91 1f 01 	lds	r25, 0x011F
   1eaa8:	90 93 24 01 	sts	0x0124, r25
   1eaac:	80 93 23 01 	sts	0x0123, r24
   1eab0:	82 e0       	ldi	r24, 0x02	; 2
   1eab2:	80 93 27 01 	sts	0x0127, r24
   1eab6:	84 e0       	ldi	r24, 0x04	; 4
   1eab8:	80 93 2c 01 	sts	0x012C, r24
   1eabc:	80 91 12 01 	lds	r24, 0x0112
   1eac0:	80 93 2d 01 	sts	0x012D, r24
   1eac4:	b6 c1       	rjmp	.+876    	; 0x1ee32 <can_isp_protocol_task+0x456>
   1eac6:	80 91 12 01 	lds	r24, 0x0112
   1eaca:	88 23       	and	r24, r24
   1eacc:	09 f4       	brne	.+2      	; 0x1ead0 <can_isp_protocol_task+0xf4>
   1eace:	b3 c1       	rjmp	.+870    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ead0:	80 91 0a 01 	lds	r24, 0x010A
   1ead4:	80 38       	cpi	r24, 0x80	; 128
   1ead6:	81 f4       	brne	.+32     	; 0x1eaf8 <can_isp_protocol_task+0x11c>
   1ead8:	80 91 0b 01 	lds	r24, 0x010B
   1eadc:	8f 3f       	cpi	r24, 0xFF	; 255
   1eade:	09 f0       	breq	.+2      	; 0x1eae2 <can_isp_protocol_task+0x106>
   1eae0:	97 c1       	rjmp	.+814    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1eae2:	80 91 0c 01 	lds	r24, 0x010C
   1eae6:	8f 3f       	cpi	r24, 0xFF	; 255
   1eae8:	09 f0       	breq	.+2      	; 0x1eaec <can_isp_protocol_task+0x110>
   1eaea:	92 c1       	rjmp	.+804    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1eaec:	0e 94 9f ff 	call	0x1ff3e	; 0x1ff3e <isp_memory_erase>
   1eaf0:	88 23       	and	r24, r24
   1eaf2:	09 f0       	breq	.+2      	; 0x1eaf6 <can_isp_protocol_task+0x11a>
   1eaf4:	3f c0       	rjmp	.+126    	; 0x1eb74 <can_isp_protocol_task+0x198>
   1eaf6:	8c c1       	rjmp	.+792    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1eaf8:	88 23       	and	r24, r24
   1eafa:	09 f0       	breq	.+2      	; 0x1eafe <can_isp_protocol_task+0x122>
   1eafc:	89 c1       	rjmp	.+786    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1eafe:	60 91 0d 01 	lds	r22, 0x010D
   1eb02:	77 27       	eor	r23, r23
   1eb04:	76 2f       	mov	r23, r22
   1eb06:	66 27       	eor	r22, r22
   1eb08:	80 91 0e 01 	lds	r24, 0x010E
   1eb0c:	99 27       	eor	r25, r25
   1eb0e:	68 2b       	or	r22, r24
   1eb10:	79 2b       	or	r23, r25
   1eb12:	80 91 0b 01 	lds	r24, 0x010B
   1eb16:	99 27       	eor	r25, r25
   1eb18:	98 2f       	mov	r25, r24
   1eb1a:	88 27       	eor	r24, r24
   1eb1c:	20 91 0c 01 	lds	r18, 0x010C
   1eb20:	33 27       	eor	r19, r19
   1eb22:	82 2b       	or	r24, r18
   1eb24:	93 2b       	or	r25, r19
   1eb26:	0e 94 02 fd 	call	0x1fa04	; 0x1fa04 <isp_address_range>
   1eb2a:	10 92 58 02 	sts	0x0258, r1
   1eb2e:	10 92 57 02 	sts	0x0257, r1
   1eb32:	21 e0       	ldi	r18, 0x01	; 1
   1eb34:	20 93 2b 01 	sts	0x012B, r18
   1eb38:	80 91 52 02 	lds	r24, 0x0252
   1eb3c:	90 91 53 02 	lds	r25, 0x0253
   1eb40:	90 93 5d 02 	sts	0x025D, r25
   1eb44:	80 93 5c 02 	sts	0x025C, r24
   1eb48:	80 91 54 02 	lds	r24, 0x0254
   1eb4c:	90 91 55 02 	lds	r25, 0x0255
   1eb50:	90 93 5b 02 	sts	0x025B, r25
   1eb54:	80 93 5a 02 	sts	0x025A, r24
   1eb58:	80 91 1e 01 	lds	r24, 0x011E
   1eb5c:	90 91 1f 01 	lds	r25, 0x011F
   1eb60:	01 96       	adiw	r24, 0x01	; 1
   1eb62:	90 93 24 01 	sts	0x0124, r25
   1eb66:	80 93 23 01 	sts	0x0123, r24
   1eb6a:	10 92 2c 01 	sts	0x012C, r1
   1eb6e:	20 93 27 01 	sts	0x0127, r18
   1eb72:	13 c0       	rjmp	.+38     	; 0x1eb9a <can_isp_protocol_task+0x1be>
   1eb74:	80 91 1e 01 	lds	r24, 0x011E
   1eb78:	90 91 1f 01 	lds	r25, 0x011F
   1eb7c:	01 96       	adiw	r24, 0x01	; 1
   1eb7e:	90 93 24 01 	sts	0x0124, r25
   1eb82:	80 93 23 01 	sts	0x0123, r24
   1eb86:	10 92 2c 01 	sts	0x012C, r1
   1eb8a:	81 e0       	ldi	r24, 0x01	; 1
   1eb8c:	80 93 27 01 	sts	0x0127, r24
   1eb90:	80 91 2b 01 	lds	r24, 0x012B
   1eb94:	81 30       	cpi	r24, 0x01	; 1
   1eb96:	09 f0       	breq	.+2      	; 0x1eb9a <can_isp_protocol_task+0x1be>
   1eb98:	4c c1       	rjmp	.+664    	; 0x1ee32 <can_isp_protocol_task+0x456>
   1eb9a:	10 92 27 01 	sts	0x0127, r1
   1eb9e:	49 c1       	rjmp	.+658    	; 0x1ee32 <can_isp_protocol_task+0x456>
   1eba0:	80 91 12 01 	lds	r24, 0x0112
   1eba4:	88 23       	and	r24, r24
   1eba6:	09 f4       	brne	.+2      	; 0x1ebaa <can_isp_protocol_task+0x1ce>
   1eba8:	46 c1       	rjmp	.+652    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ebaa:	80 91 2b 01 	lds	r24, 0x012B
   1ebae:	81 30       	cpi	r24, 0x01	; 1
   1ebb0:	09 f0       	breq	.+2      	; 0x1ebb4 <can_isp_protocol_task+0x1d8>
   1ebb2:	2e c1       	rjmp	.+604    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1ebb4:	20 91 1a 01 	lds	r18, 0x011A
   1ebb8:	60 91 57 02 	lds	r22, 0x0257
   1ebbc:	70 91 58 02 	lds	r23, 0x0258
   1ebc0:	db 01       	movw	r26, r22
   1ebc2:	ae 5a       	subi	r26, 0xAE	; 174
   1ebc4:	be 4f       	sbci	r27, 0xFE	; 254
   1ebc6:	90 e0       	ldi	r25, 0x00	; 0
   1ebc8:	08 c0       	rjmp	.+16     	; 0x1ebda <can_isp_protocol_task+0x1fe>
   1ebca:	e9 2f       	mov	r30, r25
   1ebcc:	ff 27       	eor	r31, r31
   1ebce:	e6 5f       	subi	r30, 0xF6	; 246
   1ebd0:	fe 4f       	sbci	r31, 0xFE	; 254
   1ebd2:	80 81       	ld	r24, Z
   1ebd4:	8d 93       	st	X+, r24
   1ebd6:	9f 5f       	subi	r25, 0xFF	; 255
   1ebd8:	40 e0       	ldi	r20, 0x00	; 0
   1ebda:	92 17       	cp	r25, r18
   1ebdc:	b1 f7       	brne	.-20     	; 0x1ebca <can_isp_protocol_task+0x1ee>
   1ebde:	62 0f       	add	r22, r18
   1ebe0:	71 1d       	adc	r23, r1
   1ebe2:	70 93 58 02 	sts	0x0258, r23
   1ebe6:	60 93 57 02 	sts	0x0257, r22
   1ebea:	69 3f       	cpi	r22, 0xF9	; 249
   1ebec:	71 05       	cpc	r23, r1
   1ebee:	38 f4       	brcc	.+14     	; 0x1ebfe <can_isp_protocol_task+0x222>
   1ebf0:	80 91 54 02 	lds	r24, 0x0254
   1ebf4:	90 91 55 02 	lds	r25, 0x0255
   1ebf8:	68 17       	cp	r22, r24
   1ebfa:	79 07       	cpc	r23, r25
   1ebfc:	49 f4       	brne	.+18     	; 0x1ec10 <can_isp_protocol_task+0x234>
   1ebfe:	82 e5       	ldi	r24, 0x52	; 82
   1ec00:	91 e0       	ldi	r25, 0x01	; 1
   1ec02:	0e 94 2b fd 	call	0x1fa56	; 0x1fa56 <isp_prog_block>
   1ec06:	48 2f       	mov	r20, r24
   1ec08:	10 92 58 02 	sts	0x0258, r1
   1ec0c:	10 92 57 02 	sts	0x0257, r1
   1ec10:	80 91 1e 01 	lds	r24, 0x011E
   1ec14:	90 91 1f 01 	lds	r25, 0x011F
   1ec18:	02 96       	adiw	r24, 0x02	; 2
   1ec1a:	90 93 24 01 	sts	0x0124, r25
   1ec1e:	80 93 23 01 	sts	0x0123, r24
   1ec22:	81 e0       	ldi	r24, 0x01	; 1
   1ec24:	80 93 27 01 	sts	0x0127, r24
   1ec28:	44 23       	and	r20, r20
   1ec2a:	21 f4       	brne	.+8      	; 0x1ec34 <can_isp_protocol_task+0x258>
   1ec2c:	82 e0       	ldi	r24, 0x02	; 2
   1ec2e:	80 93 2c 01 	sts	0x012C, r24
   1ec32:	ff c0       	rjmp	.+510    	; 0x1ee32 <can_isp_protocol_task+0x456>
   1ec34:	41 30       	cpi	r20, 0x01	; 1
   1ec36:	a9 f4       	brne	.+42     	; 0x1ec62 <can_isp_protocol_task+0x286>
   1ec38:	10 92 2c 01 	sts	0x012C, r1
   1ec3c:	10 92 2b 01 	sts	0x012B, r1
   1ec40:	80 91 5c 02 	lds	r24, 0x025C
   1ec44:	90 91 5d 02 	lds	r25, 0x025D
   1ec48:	90 93 53 02 	sts	0x0253, r25
   1ec4c:	80 93 52 02 	sts	0x0252, r24
   1ec50:	80 91 5a 02 	lds	r24, 0x025A
   1ec54:	90 91 5b 02 	lds	r25, 0x025B
   1ec58:	90 93 55 02 	sts	0x0255, r25
   1ec5c:	80 93 54 02 	sts	0x0254, r24
   1ec60:	e8 c0       	rjmp	.+464    	; 0x1ee32 <can_isp_protocol_task+0x456>
   1ec62:	10 92 2b 01 	sts	0x012B, r1
   1ec66:	d4 c0       	rjmp	.+424    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1ec68:	80 91 12 01 	lds	r24, 0x0112
   1ec6c:	88 23       	and	r24, r24
   1ec6e:	09 f4       	brne	.+2      	; 0x1ec72 <can_isp_protocol_task+0x296>
   1ec70:	e2 c0       	rjmp	.+452    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ec72:	2d 5f       	subi	r18, 0xFD	; 253
   1ec74:	3f 4f       	sbci	r19, 0xFF	; 255
   1ec76:	30 93 24 01 	sts	0x0124, r19
   1ec7a:	20 93 23 01 	sts	0x0123, r18
   1ec7e:	10 92 27 01 	sts	0x0127, r1
   1ec82:	60 91 0d 01 	lds	r22, 0x010D
   1ec86:	77 27       	eor	r23, r23
   1ec88:	76 2f       	mov	r23, r22
   1ec8a:	66 27       	eor	r22, r22
   1ec8c:	80 91 0e 01 	lds	r24, 0x010E
   1ec90:	99 27       	eor	r25, r25
   1ec92:	68 2b       	or	r22, r24
   1ec94:	79 2b       	or	r23, r25
   1ec96:	80 91 0b 01 	lds	r24, 0x010B
   1ec9a:	99 27       	eor	r25, r25
   1ec9c:	98 2f       	mov	r25, r24
   1ec9e:	88 27       	eor	r24, r24
   1eca0:	20 91 0c 01 	lds	r18, 0x010C
   1eca4:	33 27       	eor	r19, r19
   1eca6:	82 2b       	or	r24, r18
   1eca8:	93 2b       	or	r25, r19
   1ecaa:	0e 94 02 fd 	call	0x1fa04	; 0x1fa04 <isp_address_range>
   1ecae:	80 91 52 02 	lds	r24, 0x0252
   1ecb2:	90 91 53 02 	lds	r25, 0x0253
   1ecb6:	90 93 5d 02 	sts	0x025D, r25
   1ecba:	80 93 5c 02 	sts	0x025C, r24
   1ecbe:	80 91 54 02 	lds	r24, 0x0254
   1ecc2:	90 91 55 02 	lds	r25, 0x0255
   1ecc6:	90 93 5b 02 	sts	0x025B, r25
   1ecca:	80 93 5a 02 	sts	0x025A, r24
   1ecce:	80 91 0a 01 	lds	r24, 0x010A
   1ecd2:	88 23       	and	r24, r24
   1ecd4:	c1 f4       	brne	.+48     	; 0x1ed06 <can_isp_protocol_task+0x32a>
   1ecd6:	88 e0       	ldi	r24, 0x08	; 8
   1ecd8:	80 93 27 01 	sts	0x0127, r24
   1ecdc:	68 e0       	ldi	r22, 0x08	; 8
   1ecde:	70 e0       	ldi	r23, 0x00	; 0
   1ece0:	8c e2       	ldi	r24, 0x2C	; 44
   1ece2:	91 e0       	ldi	r25, 0x01	; 1
   1ece4:	0e 94 18 fe 	call	0x1fc30	; 0x1fc30 <isp_read_block>
   1ece8:	88 23       	and	r24, r24
   1ecea:	19 f4       	brne	.+6      	; 0x1ecf2 <can_isp_protocol_task+0x316>
   1ecec:	0e 94 86 f4 	call	0x1e90c	; 0x1e90c <can_isp_send_frame>
   1ecf0:	f5 cf       	rjmp	.-22     	; 0x1ecdc <can_isp_protocol_task+0x300>
   1ecf2:	81 30       	cpi	r24, 0x01	; 1
   1ecf4:	29 f4       	brne	.+10     	; 0x1ed00 <can_isp_protocol_task+0x324>
   1ecf6:	80 91 54 02 	lds	r24, 0x0254
   1ecfa:	80 93 27 01 	sts	0x0127, r24
   1ecfe:	17 c0       	rjmp	.+46     	; 0x1ed2e <can_isp_protocol_task+0x352>
   1ed00:	0e 94 93 f4 	call	0x1e926	; 0x1e926 <can_isp_send_error_frame>
   1ed04:	16 c0       	rjmp	.+44     	; 0x1ed32 <can_isp_protocol_task+0x356>
   1ed06:	80 38       	cpi	r24, 0x80	; 128
   1ed08:	09 f0       	breq	.+2      	; 0x1ed0c <can_isp_protocol_task+0x330>
   1ed0a:	82 c0       	rjmp	.+260    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1ed0c:	0e 94 a7 fd 	call	0x1fb4e	; 0x1fb4e <isp_blank_check>
   1ed10:	88 23       	and	r24, r24
   1ed12:	69 f4       	brne	.+26     	; 0x1ed2e <can_isp_protocol_task+0x352>
   1ed14:	82 e0       	ldi	r24, 0x02	; 2
   1ed16:	80 93 27 01 	sts	0x0127, r24
   1ed1a:	20 91 52 02 	lds	r18, 0x0252
   1ed1e:	30 91 53 02 	lds	r19, 0x0253
   1ed22:	83 2f       	mov	r24, r19
   1ed24:	99 27       	eor	r25, r25
   1ed26:	80 93 2c 01 	sts	0x012C, r24
   1ed2a:	20 93 2d 01 	sts	0x012D, r18
   1ed2e:	0e 94 86 f4 	call	0x1e90c	; 0x1e90c <can_isp_send_frame>
   1ed32:	80 91 5c 02 	lds	r24, 0x025C
   1ed36:	90 91 5d 02 	lds	r25, 0x025D
   1ed3a:	90 93 53 02 	sts	0x0253, r25
   1ed3e:	80 93 52 02 	sts	0x0252, r24
   1ed42:	80 91 5a 02 	lds	r24, 0x025A
   1ed46:	90 91 5b 02 	lds	r25, 0x025B
   1ed4a:	90 93 55 02 	sts	0x0255, r25
   1ed4e:	80 93 54 02 	sts	0x0254, r24
   1ed52:	71 c0       	rjmp	.+226    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ed54:	80 91 12 01 	lds	r24, 0x0112
   1ed58:	88 23       	and	r24, r24
   1ed5a:	09 f4       	brne	.+2      	; 0x1ed5e <can_isp_protocol_task+0x382>
   1ed5c:	6c c0       	rjmp	.+216    	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ed5e:	80 91 0a 01 	lds	r24, 0x010A
   1ed62:	83 30       	cpi	r24, 0x03	; 3
   1ed64:	09 f0       	breq	.+2      	; 0x1ed68 <can_isp_protocol_task+0x38c>
   1ed66:	54 c0       	rjmp	.+168    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1ed68:	80 91 1a 01 	lds	r24, 0x011A
   1ed6c:	82 30       	cpi	r24, 0x02	; 2
   1ed6e:	a9 f4       	brne	.+42     	; 0x1ed9a <can_isp_protocol_task+0x3be>
   1ed70:	80 91 0b 01 	lds	r24, 0x010B
   1ed74:	88 23       	and	r24, r24
   1ed76:	09 f0       	breq	.+2      	; 0x1ed7a <can_isp_protocol_task+0x39e>
   1ed78:	4b c0       	rjmp	.+150    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1ed7a:	60 e0       	ldi	r22, 0x00	; 0
   1ed7c:	88 ef       	ldi	r24, 0xF8	; 248
   1ed7e:	9f ef       	ldi	r25, 0xFF	; 255
   1ed80:	0e 94 18 fd 	call	0x1fa30	; 0x1fa30 <put_conf_byte>
   1ed84:	60 e0       	ldi	r22, 0x00	; 0
   1ed86:	89 ef       	ldi	r24, 0xF9	; 249
   1ed88:	9f ef       	ldi	r25, 0xFF	; 255
   1ed8a:	0e 94 18 fd 	call	0x1fa30	; 0x1fa30 <put_conf_byte>
   1ed8e:	80 91 60 00 	lds	r24, 0x0060
   1ed92:	88 60       	ori	r24, 0x08	; 8
   1ed94:	80 93 60 00 	sts	0x0060, r24
   1ed98:	ff cf       	rjmp	.-2      	; 0x1ed98 <can_isp_protocol_task+0x3bc>
   1ed9a:	84 30       	cpi	r24, 0x04	; 4
   1ed9c:	c9 f5       	brne	.+114    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1ed9e:	80 91 0b 01 	lds	r24, 0x010B
   1eda2:	81 30       	cpi	r24, 0x01	; 1
   1eda4:	a9 f5       	brne	.+106    	; 0x1ee10 <can_isp_protocol_task+0x434>
   1eda6:	60 91 0c 01 	lds	r22, 0x010C
   1edaa:	88 ef       	ldi	r24, 0xF8	; 248
   1edac:	9f ef       	ldi	r25, 0xFF	; 255
   1edae:	0e 94 18 fd 	call	0x1fa30	; 0x1fa30 <put_conf_byte>
   1edb2:	60 91 0d 01 	lds	r22, 0x010D
   1edb6:	89 ef       	ldi	r24, 0xF9	; 249
   1edb8:	9f ef       	ldi	r25, 0xFF	; 255
   1edba:	0e 94 18 fd 	call	0x1fa30	; 0x1fa30 <put_conf_byte>
   1edbe:	80 91 0c 01 	lds	r24, 0x010C
   1edc2:	99 27       	eor	r25, r25
   1edc4:	98 2f       	mov	r25, r24
   1edc6:	88 27       	eor	r24, r24
   1edc8:	20 91 0d 01 	lds	r18, 0x010D
   1edcc:	33 27       	eor	r19, r19
   1edce:	82 2b       	or	r24, r18
   1edd0:	93 2b       	or	r25, r19
   1edd2:	0e 94 f2 fc 	call	0x1f9e4	; 0x1f9e4 <isp_jump_to>
   1edd6:	2f c0       	rjmp	.+94     	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1edd8:	80 91 12 01 	lds	r24, 0x0112
   1eddc:	88 23       	and	r24, r24
   1edde:	59 f1       	breq	.+86     	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ede0:	80 91 0a 01 	lds	r24, 0x010A
   1ede4:	88 23       	and	r24, r24
   1ede6:	b9 f0       	breq	.+46     	; 0x1ee16 <can_isp_protocol_task+0x43a>
   1ede8:	81 30       	cpi	r24, 0x01	; 1
   1edea:	29 f4       	brne	.+10     	; 0x1edf6 <can_isp_protocol_task+0x41a>
   1edec:	80 91 0b 01 	lds	r24, 0x010B
   1edf0:	0e 94 fc fc 	call	0x1f9f8	; 0x1f9f8 <isp_set_memory>
   1edf4:	10 c0       	rjmp	.+32     	; 0x1ee16 <can_isp_protocol_task+0x43a>
   1edf6:	82 30       	cpi	r24, 0x02	; 2
   1edf8:	31 f0       	breq	.+12     	; 0x1ee06 <can_isp_protocol_task+0x42a>
   1edfa:	83 30       	cpi	r24, 0x03	; 3
   1edfc:	49 f4       	brne	.+18     	; 0x1ee10 <can_isp_protocol_task+0x434>
   1edfe:	80 91 0b 01 	lds	r24, 0x010B
   1ee02:	0e 94 fc fc 	call	0x1f9f8	; 0x1f9f8 <isp_set_memory>
   1ee06:	80 91 0c 01 	lds	r24, 0x010C
   1ee0a:	0e 94 ff fc 	call	0x1f9fe	; 0x1f9fe <isp_set_page>
   1ee0e:	03 c0       	rjmp	.+6      	; 0x1ee16 <can_isp_protocol_task+0x43a>
   1ee10:	0e 94 93 f4 	call	0x1e926	; 0x1e926 <can_isp_send_error_frame>
   1ee14:	10 c0       	rjmp	.+32     	; 0x1ee36 <can_isp_protocol_task+0x45a>
   1ee16:	80 91 1e 01 	lds	r24, 0x011E
   1ee1a:	90 91 1f 01 	lds	r25, 0x011F
   1ee1e:	06 96       	adiw	r24, 0x06	; 6
   1ee20:	90 93 24 01 	sts	0x0124, r25
   1ee24:	80 93 23 01 	sts	0x0123, r24
   1ee28:	81 e0       	ldi	r24, 0x01	; 1
   1ee2a:	80 93 27 01 	sts	0x0127, r24
   1ee2e:	10 92 2c 01 	sts	0x012C, r1
   1ee32:	0e 94 86 f4 	call	0x1e90c	; 0x1e90c <can_isp_send_frame>
   1ee36:	81 e0       	ldi	r24, 0x01	; 1
   1ee38:	90 e0       	ldi	r25, 0x00	; 0
   1ee3a:	1f 91       	pop	r17
   1ee3c:	08 95       	ret

0001ee3e <can_cmd>:
//!         CAN_CMD_REFUSED  - command is refused
//!
//------------------------------------------------------------------------------
U8 can_cmd(st_cmd_t* cmd)
{
   1ee3e:	cf 93       	push	r28
   1ee40:	df 93       	push	r29
   1ee42:	dc 01       	movw	r26, r24
U8  cpt;
U8  rtn_val;

    rtn_val = CAN_CMD_ACCEPTED;
    cmd->status = MOB_PENDING;
   1ee44:	80 e6       	ldi	r24, 0x60	; 96
   1ee46:	ed 01       	movw	r28, r26
   1ee48:	8a 87       	std	Y+10, r24	; 0x0a

    //------------ special for "reduced_can_lib.c"
    if ((cmd->cmd) == CMD_TX_DATA)
   1ee4a:	89 81       	ldd	r24, Y+1	; 0x01
   1ee4c:	9a 81       	ldd	r25, Y+2	; 0x02
   1ee4e:	81 30       	cpi	r24, 0x01	; 1
   1ee50:	91 05       	cpc	r25, r1
   1ee52:	09 f0       	breq	.+2      	; 0x1ee56 <can_cmd+0x18>
   1ee54:	48 c0       	rjmp	.+144    	; 0x1eee6 <can_cmd+0xa8>
    {
        cmd->handle = MOB_14;
   1ee56:	8e e0       	ldi	r24, 0x0E	; 14
   1ee58:	8c 93       	st	X, r24
        Can_set_mob(MOB_14);
   1ee5a:	80 ee       	ldi	r24, 0xE0	; 224
   1ee5c:	80 93 ed 00 	sts	0x00ED, r24
   1ee60:	ee ee       	ldi	r30, 0xEE	; 238
   1ee62:	f0 e0       	ldi	r31, 0x00	; 0
        Can_clear_mob();
   1ee64:	11 92       	st	Z+, r1
   1ee66:	e8 3f       	cpi	r30, 0xF8	; 248
   1ee68:	f1 05       	cpc	r31, r1
   1ee6a:	e1 f7       	brne	.-8      	; 0x1ee64 <can_cmd+0x26>
        Can_clear_ide();
   1ee6c:	80 91 ef 00 	lds	r24, 0x00EF
   1ee70:	8f 7e       	andi	r24, 0xEF	; 239
   1ee72:	80 93 ef 00 	sts	0x00EF, r24
        Can_set_std_id(cmd->id.std);
   1ee76:	fd 01       	movw	r30, r26
   1ee78:	94 81       	ldd	r25, Z+4	; 0x04
   1ee7a:	83 81       	ldd	r24, Z+3	; 0x03
   1ee7c:	92 95       	swap	r25
   1ee7e:	99 0f       	add	r25, r25
   1ee80:	90 7e       	andi	r25, 0xE0	; 224
   1ee82:	86 95       	lsr	r24
   1ee84:	86 95       	lsr	r24
   1ee86:	86 95       	lsr	r24
   1ee88:	98 0f       	add	r25, r24
   1ee8a:	90 93 f3 00 	sts	0x00F3, r25
   1ee8e:	83 81       	ldd	r24, Z+3	; 0x03
   1ee90:	82 95       	swap	r24
   1ee92:	88 0f       	add	r24, r24
   1ee94:	80 7e       	andi	r24, 0xE0	; 224
   1ee96:	80 93 f2 00 	sts	0x00F2, r24
   1ee9a:	80 91 ef 00 	lds	r24, 0x00EF
   1ee9e:	8f 7e       	andi	r24, 0xEF	; 239
   1eea0:	80 93 ef 00 	sts	0x00EF, r24
        for (cpt=0; cpt<cmd->dlc; cpt++) CANMSG = *(cmd->pt_data + cpt);
   1eea4:	27 81       	ldd	r18, Z+7	; 0x07
   1eea6:	90 e0       	ldi	r25, 0x00	; 0
   1eea8:	09 c0       	rjmp	.+18     	; 0x1eebc <can_cmd+0x7e>
   1eeaa:	ed 01       	movw	r28, r26
   1eeac:	e8 85       	ldd	r30, Y+8	; 0x08
   1eeae:	f9 85       	ldd	r31, Y+9	; 0x09
   1eeb0:	e9 0f       	add	r30, r25
   1eeb2:	f1 1d       	adc	r31, r1
   1eeb4:	80 81       	ld	r24, Z
   1eeb6:	80 93 fa 00 	sts	0x00FA, r24
   1eeba:	9f 5f       	subi	r25, 0xFF	; 255
   1eebc:	92 17       	cp	r25, r18
   1eebe:	a9 f7       	brne	.-22     	; 0x1eeaa <can_cmd+0x6c>
        Can_clear_rtr();
   1eec0:	80 91 f0 00 	lds	r24, 0x00F0
   1eec4:	8b 7f       	andi	r24, 0xFB	; 251
   1eec6:	80 93 f0 00 	sts	0x00F0, r24
        Can_set_dlc(cmd->dlc);
   1eeca:	80 91 ef 00 	lds	r24, 0x00EF
   1eece:	82 2b       	or	r24, r18
   1eed0:	80 93 ef 00 	sts	0x00EF, r24
        Can_config_tx();
   1eed4:	80 91 ef 00 	lds	r24, 0x00EF
   1eed8:	8f 73       	andi	r24, 0x3F	; 63
   1eeda:	80 93 ef 00 	sts	0x00EF, r24
   1eede:	80 91 ef 00 	lds	r24, 0x00EF
   1eee2:	80 64       	ori	r24, 0x40	; 64
   1eee4:	51 c0       	rjmp	.+162    	; 0x1ef88 <can_cmd+0x14a>
    }
    //------------ special for "reduced_can_lib.c"
    else if ((cmd->cmd) == CMD_RX_DATA_MASKED)
   1eee6:	02 97       	sbiw	r24, 0x02	; 2
   1eee8:	11 f0       	breq	.+4      	; 0x1eeee <can_cmd+0xb0>
   1eeea:	8f ef       	ldi	r24, 0xFF	; 255
   1eeec:	50 c0       	rjmp	.+160    	; 0x1ef8e <can_cmd+0x150>
    {
        cmd->handle = MOB_0;
   1eeee:	1c 92       	st	X, r1
        Can_set_mob(MOB_0);
   1eef0:	10 92 ed 00 	sts	0x00ED, r1
   1eef4:	ee ee       	ldi	r30, 0xEE	; 238
   1eef6:	f0 e0       	ldi	r31, 0x00	; 0
        Can_clear_mob();
   1eef8:	11 92       	st	Z+, r1
   1eefa:	e8 3f       	cpi	r30, 0xF8	; 248
   1eefc:	f1 05       	cpc	r31, r1
   1eefe:	e1 f7       	brne	.-8      	; 0x1eef8 <can_cmd+0xba>
        Can_clear_ide();
   1ef00:	80 91 ef 00 	lds	r24, 0x00EF
   1ef04:	8f 7e       	andi	r24, 0xEF	; 239
   1ef06:	80 93 ef 00 	sts	0x00EF, r24
        Can_set_std_id(cmd->id.std);
   1ef0a:	fd 01       	movw	r30, r26
   1ef0c:	94 81       	ldd	r25, Z+4	; 0x04
   1ef0e:	83 81       	ldd	r24, Z+3	; 0x03
   1ef10:	92 95       	swap	r25
   1ef12:	99 0f       	add	r25, r25
   1ef14:	90 7e       	andi	r25, 0xE0	; 224
   1ef16:	86 95       	lsr	r24
   1ef18:	86 95       	lsr	r24
   1ef1a:	86 95       	lsr	r24
   1ef1c:	98 0f       	add	r25, r24
   1ef1e:	90 93 f3 00 	sts	0x00F3, r25
   1ef22:	83 81       	ldd	r24, Z+3	; 0x03
   1ef24:	82 95       	swap	r24
   1ef26:	88 0f       	add	r24, r24
   1ef28:	80 7e       	andi	r24, 0xE0	; 224
   1ef2a:	80 93 f2 00 	sts	0x00F2, r24
   1ef2e:	80 91 ef 00 	lds	r24, 0x00EF
   1ef32:	8f 7e       	andi	r24, 0xEF	; 239
   1ef34:	80 93 ef 00 	sts	0x00EF, r24
        Can_set_std_msk(cmd->msk.std);
   1ef38:	96 81       	ldd	r25, Z+6	; 0x06
   1ef3a:	85 81       	ldd	r24, Z+5	; 0x05
   1ef3c:	92 95       	swap	r25
   1ef3e:	99 0f       	add	r25, r25
   1ef40:	90 7e       	andi	r25, 0xE0	; 224
   1ef42:	86 95       	lsr	r24
   1ef44:	86 95       	lsr	r24
   1ef46:	86 95       	lsr	r24
   1ef48:	98 0f       	add	r25, r24
   1ef4a:	90 93 f7 00 	sts	0x00F7, r25
   1ef4e:	85 81       	ldd	r24, Z+5	; 0x05
   1ef50:	82 95       	swap	r24
   1ef52:	88 0f       	add	r24, r24
   1ef54:	80 7e       	andi	r24, 0xE0	; 224
   1ef56:	80 93 f6 00 	sts	0x00F6, r24
        Can_set_rtrmsk(); Can_clear_rtr();
   1ef5a:	80 91 f4 00 	lds	r24, 0x00F4
   1ef5e:	84 60       	ori	r24, 0x04	; 4
   1ef60:	80 93 f4 00 	sts	0x00F4, r24
   1ef64:	80 91 f0 00 	lds	r24, 0x00F0
   1ef68:	8b 7f       	andi	r24, 0xFB	; 251
   1ef6a:	80 93 f0 00 	sts	0x00F0, r24
        Can_set_idemsk();
   1ef6e:	80 91 f4 00 	lds	r24, 0x00F4
   1ef72:	81 60       	ori	r24, 0x01	; 1
   1ef74:	80 93 f4 00 	sts	0x00F4, r24
        Can_config_rx();
   1ef78:	80 91 ef 00 	lds	r24, 0x00EF
   1ef7c:	8f 73       	andi	r24, 0x3F	; 63
   1ef7e:	80 93 ef 00 	sts	0x00EF, r24
   1ef82:	80 91 ef 00 	lds	r24, 0x00EF
   1ef86:	80 68       	ori	r24, 0x80	; 128
   1ef88:	80 93 ef 00 	sts	0x00EF, r24
   1ef8c:	80 e0       	ldi	r24, 0x00	; 0
    }
    // case CMD_NONE or not implemented command
    else rtn_val= CAN_CMD_REFUSED;

    return rtn_val;
}
   1ef8e:	99 27       	eor	r25, r25
   1ef90:	df 91       	pop	r29
   1ef92:	cf 91       	pop	r28
   1ef94:	08 95       	ret

0001ef96 <can_get_status>:

//------------------------------------------------------------------------------
//  @fn can_get_status
//!
//! This function allows to return if the command has been performed or not.
//! In an reception case, all the CAN message is stored in the structure.
//! This function also updates the CAN descriptor status (MOB_TX_COMPLETED,
//!  MOB_RX_COMPLETED, MOB_RX_COMPLETED_DLCW or MOB_???_ERROR).
//!
//! @param  st_cmd_t* pointer on CAN descriptor structure.
//!
//! @return CAN_STATUS_COMPLETED     - Rx or Tx is completed
//!         CAN_STATUS_NOT_COMPLETED - Rx or Tx is not completed
//!         CAN_STATUS_ERROR         - Error in configuration or in the
//!                                    CAN communication
//!
//------------------------------------------------------------------------------
U8 can_get_status (st_cmd_t* cmd)
{
   1ef96:	1f 93       	push	r17
   1ef98:	cf 93       	push	r28
   1ef9a:	df 93       	push	r29
   1ef9c:	ec 01       	movw	r28, r24
U8 a_status;
U8 rtn_val;

    a_status = cmd->status;
   1ef9e:	8a 85       	ldd	r24, Y+10	; 0x0a
    if ( (a_status==STATUS_CLEARED)||(a_status==MOB_NOT_REACHED)||(a_status==MOB_DISABLE) )
   1efa0:	88 23       	and	r24, r24
   1efa2:	09 f4       	brne	.+2      	; 0x1efa6 <can_get_status+0x10>
   1efa4:	4b c0       	rjmp	.+150    	; 0x1f03c <can_get_status+0xa6>
   1efa6:	8f 31       	cpi	r24, 0x1F	; 31
   1efa8:	09 f4       	brne	.+2      	; 0x1efac <can_get_status+0x16>
   1efaa:	48 c0       	rjmp	.+144    	; 0x1f03c <can_get_status+0xa6>
   1efac:	8f 3f       	cpi	r24, 0xFF	; 255
   1efae:	09 f4       	brne	.+2      	; 0x1efb2 <can_get_status+0x1c>
   1efb0:	45 c0       	rjmp	.+138    	; 0x1f03c <can_get_status+0xa6>
    {
        return CAN_STATUS_ERROR;
    }

    Can_set_mob(cmd->handle);
   1efb2:	88 81       	ld	r24, Y
   1efb4:	82 95       	swap	r24
   1efb6:	80 7f       	andi	r24, 0xF0	; 240
   1efb8:	80 93 ed 00 	sts	0x00ED, r24
    a_status = can_get_mob_status();
   1efbc:	0e 94 c0 f2 	call	0x1e580	; 0x1e580 <can_get_mob_status>
   1efc0:	18 2f       	mov	r17, r24

    switch (a_status)
   1efc2:	80 32       	cpi	r24, 0x20	; 32
   1efc4:	61 f0       	breq	.+24     	; 0x1efde <can_get_status+0x48>
   1efc6:	81 32       	cpi	r24, 0x21	; 33
   1efc8:	18 f4       	brcc	.+6      	; 0x1efd0 <can_get_status+0x3a>
   1efca:	88 23       	and	r24, r24
   1efcc:	31 f0       	breq	.+12     	; 0x1efda <can_get_status+0x44>
   1efce:	2b c0       	rjmp	.+86     	; 0x1f026 <can_get_status+0x90>
   1efd0:	80 34       	cpi	r24, 0x40	; 64
   1efd2:	f9 f0       	breq	.+62     	; 0x1f012 <can_get_status+0x7c>
   1efd4:	80 3a       	cpi	r24, 0xA0	; 160
   1efd6:	39 f5       	brne	.+78     	; 0x1f026 <can_get_status+0x90>
   1efd8:	02 c0       	rjmp	.+4      	; 0x1efde <can_get_status+0x48>
   1efda:	81 e0       	ldi	r24, 0x01	; 1
   1efdc:	2d c0       	rjmp	.+90     	; 0x1f038 <can_get_status+0xa2>
    {
        case MOB_NOT_COMPLETED:
            // cmd->status not updated
            rtn_val = CAN_STATUS_NOT_COMPLETED;
            break;
        //--------------- special for "reduced_can_lib.c"
        case MOB_RX_COMPLETED:
        case MOB_RX_COMPLETED_DLCW:
            cmd->dlc = Can_get_dlc();
   1efde:	80 91 ef 00 	lds	r24, 0x00EF
   1efe2:	8f 70       	andi	r24, 0x0F	; 15
   1efe4:	8f 83       	std	Y+7, r24	; 0x07
            can_get_data(cmd->pt_data);
   1efe6:	88 85       	ldd	r24, Y+8	; 0x08
   1efe8:	99 85       	ldd	r25, Y+9	; 0x09
   1efea:	0e 94 db f2 	call	0x1e5b6	; 0x1e5b6 <can_get_data>
            // Always standard frame
            Can_get_std_id(cmd->id.std);    //- Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined in this statement
   1efee:	80 91 f3 00 	lds	r24, 0x00F3
   1eff2:	82 95       	swap	r24
   1eff4:	86 95       	lsr	r24
   1eff6:	87 70       	andi	r24, 0x07	; 7
   1eff8:	8c 83       	std	Y+4, r24	; 0x04
   1effa:	90 91 f2 00 	lds	r25, 0x00F2
   1effe:	80 91 f3 00 	lds	r24, 0x00F3
   1f002:	92 95       	swap	r25
   1f004:	96 95       	lsr	r25
   1f006:	97 70       	andi	r25, 0x07	; 7
   1f008:	88 0f       	add	r24, r24
   1f00a:	88 0f       	add	r24, r24
   1f00c:	88 0f       	add	r24, r24
   1f00e:	98 0f       	add	r25, r24
   1f010:	9b 83       	std	Y+3, r25	; 0x03
            // Status field of descriptor: 0x20 if Rx completed
            // Status field of descriptor: 0xA0 if Rx completed with DLCWarning
            cmd->status = a_status;
            Can_mob_abort();        // Freed the MOB
            Can_clear_status_mob(); //   and reset MOb status
            rtn_val = CAN_STATUS_COMPLETED;
            break;
        //--------------- special for "reduced_can_lib.c"
        case MOB_TX_COMPLETED:
            // Status field of descriptor: 0x40 if Tx completed
            cmd->status = a_status;
   1f012:	1a 87       	std	Y+10, r17	; 0x0a
            Can_mob_abort();        // Freed the MOB
   1f014:	80 91 ef 00 	lds	r24, 0x00EF
   1f018:	8f 73       	andi	r24, 0x3F	; 63
   1f01a:	80 93 ef 00 	sts	0x00EF, r24
            Can_clear_status_mob(); //   and reset MOb status
   1f01e:	10 92 ee 00 	sts	0x00EE, r1
   1f022:	80 e0       	ldi	r24, 0x00	; 0
   1f024:	09 c0       	rjmp	.+18     	; 0x1f038 <can_get_status+0xa2>
            rtn_val = CAN_STATUS_COMPLETED;
            break;
        //---------------
        default:
            // Status field of descriptor: (bin)000b.scfa if MOb error
            cmd->status = a_status;
   1f026:	1a 87       	std	Y+10, r17	; 0x0a
            Can_mob_abort();        // Freed the MOB
   1f028:	80 91 ef 00 	lds	r24, 0x00EF
   1f02c:	8f 73       	andi	r24, 0x3F	; 63
   1f02e:	80 93 ef 00 	sts	0x00EF, r24
            Can_clear_status_mob(); //   and reset MOb status
   1f032:	10 92 ee 00 	sts	0x00EE, r1
   1f036:	82 e0       	ldi	r24, 0x02	; 2
            rtn_val = CAN_STATUS_ERROR;
            break;
    }

    return (rtn_val);
   1f038:	99 27       	eor	r25, r25
   1f03a:	02 c0       	rjmp	.+4      	; 0x1f040 <can_get_status+0xaa>
   1f03c:	82 e0       	ldi	r24, 0x02	; 2
   1f03e:	90 e0       	ldi	r25, 0x00	; 0
   1f040:	df 91       	pop	r29
   1f042:	cf 91       	pop	r28
   1f044:	1f 91       	pop	r17
   1f046:	08 95       	ret

0001f048 <eeprom_rd_byte>:
//! @return:    Value read in the Eeprom memory.
//!
//------------------------------------------------------------------------------
U8 eeprom_rd_byte(U16 addr_byte)
{
   1f048:	f9 99       	sbic	0x1f, 1	; 31
   1f04a:	fe cf       	rjmp	.-4      	; 0x1f048 <eeprom_rd_byte>
    Eeprom_prog_completed;
    return (Eeprom_rd_byte(addr_byte));
   1f04c:	fc 01       	movw	r30, r24
   1f04e:	e1 bd       	out	0x21, r30	; 33
   1f050:	f2 bd       	out	0x22, r31	; 34
   1f052:	f8 9a       	sbi	0x1f, 0	; 31
   1f054:	80 b5       	in	r24, 0x20	; 32
}
   1f056:	99 27       	eor	r25, r25
   1f058:	08 95       	ret

0001f05a <eeprom_wr_byte>:

//------------------------------------------------------------------------------
//  @fn eeprom_wr_byte
//!
//! This function allows to write a byte in up to 64K of Eeprom memory.
//!
//! @warning
//!
//! @param: addr_byte   Address in Eeprom memory to write the byte.
//!         value       Value to write in the Eeprom memory.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void eeprom_wr_byte(U16 addr_byte, U8 value)
{
   1f05a:	f9 99       	sbic	0x1f, 1	; 31
   1f05c:	fe cf       	rjmp	.-4      	; 0x1f05a <eeprom_wr_byte>
    Eeprom_prog_completed;
    Eeprom_wr_byte(addr_byte, value);
   1f05e:	fc 01       	movw	r30, r24
   1f060:	e1 bd       	out	0x21, r30	; 33
   1f062:	f2 bd       	out	0x22, r31	; 34
   1f064:	60 bd       	out	0x20, r22	; 32
   1f066:	fa 9a       	sbi	0x1f, 2	; 31
   1f068:	f9 9a       	sbi	0x1f, 1	; 31
   1f06a:	08 95       	ret

0001f06c <eeprom_wr_block>:
}

//------------------------------------------------------------------------------
//  @fn eeprom_rd_block
//!
//! This function allows to read up to 65535 bytes (64K Bytes-1 byte) of
//! the Eeprom memory.
//!
//! @warning: 1 - This function isn't able to address the fully 64K bytes
//!               but we cannot find in the device a source buffer up to
//!               64K bytes.
//!
//! @param: src    Start address in Eeprom memory where write data.
//!         *dest  Address of data to write.
//!         n      number of byte to write.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void eeprom_rd_block(U16 src, U8* dest, U16 n)
{
    for (; n != 0 ; n--)
    {
       *dest = eeprom_rd_byte(src);
        src++; dest++;
    }
}
//------------------------------------------------------------------------------
//  @fn eeprom_wr_block
//!
//! This function allows to write up to 65535 bytes (64K Bytes-1 byte) in
//! the Eeprom memory.
//!
//! @warning: 1 - This function isn't able to address the fully 64K bytes
//!               but we cannot find in the device a source buffer up to
//!               64K bytes.
//!
//! @param: *src   Address of data to write.
//!         dest   Start address in Eeprom memory where write data.
//!         n      number of byte to write.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void eeprom_wr_block(U8* src, U16 dest, U16 n)
{
   1f06c:	dc 01       	movw	r26, r24
   1f06e:	0e c0       	rjmp	.+28     	; 0x1f08c <eeprom_wr_block+0x20>
    for (; n != 0 ; n--)
    {
        eeprom_wr_byte(dest,*src);
   1f070:	8c 91       	ld	r24, X
   1f072:	f9 99       	sbic	0x1f, 1	; 31
   1f074:	fe cf       	rjmp	.-4      	; 0x1f072 <eeprom_wr_block+0x6>
   1f076:	fb 01       	movw	r30, r22
   1f078:	e1 bd       	out	0x21, r30	; 33
   1f07a:	f2 bd       	out	0x22, r31	; 34
   1f07c:	80 bd       	out	0x20, r24	; 32
   1f07e:	fa 9a       	sbi	0x1f, 2	; 31
   1f080:	f9 9a       	sbi	0x1f, 1	; 31
        src++; dest++;
   1f082:	11 96       	adiw	r26, 0x01	; 1
   1f084:	6f 5f       	subi	r22, 0xFF	; 255
   1f086:	7f 4f       	sbci	r23, 0xFF	; 255
   1f088:	41 50       	subi	r20, 0x01	; 1
   1f08a:	50 40       	sbci	r21, 0x00	; 0
   1f08c:	41 15       	cp	r20, r1
   1f08e:	51 05       	cpc	r21, r1
   1f090:	79 f7       	brne	.-34     	; 0x1f070 <eeprom_wr_block+0x4>
   1f092:	08 95       	ret

0001f094 <eeprom_full_erase>:
    }
}

//------------------------------------------------------------------------------
//  @fn eeprom_full_erase
//!
//! This function erases the whole Eeprom memory.
//!
//! @warning none
//!
//! @param none
//!
//! @return none
//!
//------------------------------------------------------------------------------
void eeprom_full_erase(void)
{
   1f094:	20 e0       	ldi	r18, 0x00	; 0
   1f096:	30 e0       	ldi	r19, 0x00	; 0
   1f098:	9f ef       	ldi	r25, 0xFF	; 255
   1f09a:	f9 99       	sbic	0x1f, 1	; 31
   1f09c:	fe cf       	rjmp	.-4      	; 0x1f09a <eeprom_full_erase+0x6>
   1f09e:	f9 01       	movw	r30, r18
   1f0a0:	e1 bd       	out	0x21, r30	; 33
   1f0a2:	f2 bd       	out	0x22, r31	; 34
   1f0a4:	f8 9a       	sbi	0x1f, 0	; 31
   1f0a6:	80 b5       	in	r24, 0x20	; 32
U16 addr;

    for(addr = 0; addr < (U16)(E2_END+1); addr++)
    {
        if ((eeprom_rd_byte(addr)) != EEPROM_BLANK_BYTE)
   1f0a8:	8f 3f       	cpi	r24, 0xFF	; 255
   1f0aa:	41 f0       	breq	.+16     	; 0x1f0bc <eeprom_full_erase+0x28>
   1f0ac:	f9 99       	sbic	0x1f, 1	; 31
   1f0ae:	fe cf       	rjmp	.-4      	; 0x1f0ac <eeprom_full_erase+0x18>
   1f0b0:	f9 01       	movw	r30, r18
   1f0b2:	e1 bd       	out	0x21, r30	; 33
   1f0b4:	f2 bd       	out	0x22, r31	; 34
   1f0b6:	90 bd       	out	0x20, r25	; 32
   1f0b8:	fa 9a       	sbi	0x1f, 2	; 31
   1f0ba:	f9 9a       	sbi	0x1f, 1	; 31
   1f0bc:	2f 5f       	subi	r18, 0xFF	; 255
   1f0be:	3f 4f       	sbci	r19, 0xFF	; 255
   1f0c0:	80 e1       	ldi	r24, 0x10	; 16
   1f0c2:	20 30       	cpi	r18, 0x00	; 0
   1f0c4:	38 07       	cpc	r19, r24
   1f0c6:	48 f3       	brcs	.-46     	; 0x1f09a <eeprom_full_erase+0x6>
   1f0c8:	08 95       	ret

0001f0ca <eeprom_rd_block>:
   1f0ca:	9c 01       	movw	r18, r24
   1f0cc:	db 01       	movw	r26, r22
   1f0ce:	0c c0       	rjmp	.+24     	; 0x1f0e8 <eeprom_rd_block+0x1e>
   1f0d0:	f9 99       	sbic	0x1f, 1	; 31
   1f0d2:	fe cf       	rjmp	.-4      	; 0x1f0d0 <eeprom_rd_block+0x6>
   1f0d4:	f9 01       	movw	r30, r18
   1f0d6:	e1 bd       	out	0x21, r30	; 33
   1f0d8:	f2 bd       	out	0x22, r31	; 34
   1f0da:	f8 9a       	sbi	0x1f, 0	; 31
   1f0dc:	80 b5       	in	r24, 0x20	; 32
   1f0de:	8d 93       	st	X+, r24
   1f0e0:	2f 5f       	subi	r18, 0xFF	; 255
   1f0e2:	3f 4f       	sbci	r19, 0xFF	; 255
   1f0e4:	41 50       	subi	r20, 0x01	; 1
   1f0e6:	50 40       	sbci	r21, 0x00	; 0
   1f0e8:	41 15       	cp	r20, r1
   1f0ea:	51 05       	cpc	r21, r1
   1f0ec:	89 f7       	brne	.-30     	; 0x1f0d0 <eeprom_rd_block+0x6>
   1f0ee:	08 95       	ret

0001f0f0 <uart_rx_get_3_data>:
//!
//! @return UART pin value sampled 3 times
//------------------------------------------------------------------------------
Bool uart_rx_get_3_data (void)
{
   1f0f0:	80 91 34 01 	lds	r24, 0x0134
   1f0f4:	88 23       	and	r24, r24
   1f0f6:	39 f4       	brne	.+14     	; 0x1f106 <uart_rx_get_3_data+0x16>
U8 u8_temp = 0;

#if ((USE_UART == UART_0) || (USE_UART == UART_1))
    u8_temp = Uart_rx_get_3_data();
    
#elif (USE_UART ==  BOTH_UART)
    if (uart_selected == UART_0)
    {
        u8_temp = (UART_0_PORT_IN  & UART_0_PORT_IN  & UART_0_PORT_IN  & (1<<UART_0_INPUT_PIN)) >> UART_0_INPUT_PIN;
   1f0f8:	8c b1       	in	r24, 0x0c	; 12
   1f0fa:	9c b1       	in	r25, 0x0c	; 12
   1f0fc:	2c b1       	in	r18, 0x0c	; 12
   1f0fe:	89 23       	and	r24, r25
   1f100:	81 70       	andi	r24, 0x01	; 1
   1f102:	28 23       	and	r18, r24
   1f104:	11 c0       	rjmp	.+34     	; 0x1f128 <uart_rx_get_3_data+0x38>
    }
    if (uart_selected == UART_1)
   1f106:	81 30       	cpi	r24, 0x01	; 1
   1f108:	11 f0       	breq	.+4      	; 0x1f10e <uart_rx_get_3_data+0x1e>
   1f10a:	20 e0       	ldi	r18, 0x00	; 0
   1f10c:	0d c0       	rjmp	.+26     	; 0x1f128 <uart_rx_get_3_data+0x38>
    {
        u8_temp = (UART_1_PORT_IN  & UART_1_PORT_IN  & UART_1_PORT_IN  & (1<<UART_1_INPUT_PIN)) >> UART_1_INPUT_PIN;
   1f10e:	89 b1       	in	r24, 0x09	; 9
   1f110:	29 b1       	in	r18, 0x09	; 9
   1f112:	39 b1       	in	r19, 0x09	; 9
   1f114:	82 23       	and	r24, r18
   1f116:	83 23       	and	r24, r19
   1f118:	99 27       	eor	r25, r25
   1f11a:	84 70       	andi	r24, 0x04	; 4
   1f11c:	90 70       	andi	r25, 0x00	; 0
   1f11e:	95 95       	asr	r25
   1f120:	87 95       	ror	r24
   1f122:	95 95       	asr	r25
   1f124:	87 95       	ror	r24
   1f126:	28 2f       	mov	r18, r24
    }
#   else
#       error USE_UART definition is not referenced in "uart_drv.h" file
#endif

    return u8_temp;
}
   1f128:	82 2f       	mov	r24, r18
   1f12a:	99 27       	eor	r25, r25
   1f12c:	08 95       	ret

0001f12e <uart_rx_get_data>:


//------------------------------------------------------------------------------
//  @fn uart_rx_get_data
//!
//! This function returns the UART pin value.
//!
//! @warning none
//!
//! @param  none
//!
//! @return UART pin value
//------------------------------------------------------------------------------
Bool uart_rx_get_data (void)
{
   1f12e:	80 91 34 01 	lds	r24, 0x0134
   1f132:	88 23       	and	r24, r24
   1f134:	19 f4       	brne	.+6      	; 0x1f13c <uart_rx_get_data+0xe>
U8 u8_temp = 0;

#if ((USE_UART == UART_0) || (USE_UART == UART_1))
    u8_temp = Uart_rx_get_data();
    
#elif (USE_UART ==  BOTH_UART)
    if (uart_selected == UART_0)
    {
        u8_temp = (UART_0_PORT_IN  & (1<<UART_0_INPUT_PIN)) >> UART_0_INPUT_PIN;
   1f136:	8c b1       	in	r24, 0x0c	; 12
   1f138:	81 70       	andi	r24, 0x01	; 1
   1f13a:	0c c0       	rjmp	.+24     	; 0x1f154 <uart_rx_get_data+0x26>
    }
    if (uart_selected == UART_1)
   1f13c:	81 30       	cpi	r24, 0x01	; 1
   1f13e:	11 f0       	breq	.+4      	; 0x1f144 <uart_rx_get_data+0x16>
   1f140:	80 e0       	ldi	r24, 0x00	; 0
   1f142:	08 c0       	rjmp	.+16     	; 0x1f154 <uart_rx_get_data+0x26>
    {
        u8_temp = (UART_1_PORT_IN  & (1<<UART_1_INPUT_PIN)) >> UART_1_INPUT_PIN;
   1f144:	89 b1       	in	r24, 0x09	; 9
   1f146:	99 27       	eor	r25, r25
   1f148:	84 70       	andi	r24, 0x04	; 4
   1f14a:	90 70       	andi	r25, 0x00	; 0
   1f14c:	95 95       	asr	r25
   1f14e:	87 95       	ror	r24
   1f150:	95 95       	asr	r25
   1f152:	87 95       	ror	r24
    }
#   else
#       error USE_UART definition is not referenced in "uart_drv.h" file
#endif

    return u8_temp;
}
   1f154:	99 27       	eor	r25, r25
   1f156:	08 95       	ret

0001f158 <uart_set_baudrate>:
   1f158:	cf 92       	push	r12
   1f15a:	df 92       	push	r13
   1f15c:	ef 92       	push	r14
   1f15e:	ff 92       	push	r15
   1f160:	0f 93       	push	r16
   1f162:	1f 93       	push	r17
   1f164:	cf 93       	push	r28
   1f166:	df 93       	push	r29
   1f168:	9b 01       	movw	r18, r22
   1f16a:	ac 01       	movw	r20, r24
   1f16c:	61 15       	cp	r22, r1
   1f16e:	71 05       	cpc	r23, r1
   1f170:	81 05       	cpc	r24, r1
   1f172:	91 05       	cpc	r25, r1
   1f174:	b1 f0       	breq	.+44     	; 0x1f1a2 <uart_set_baudrate+0x4a>
   1f176:	73 e0       	ldi	r23, 0x03	; 3
   1f178:	22 0f       	add	r18, r18
   1f17a:	33 1f       	adc	r19, r19
   1f17c:	44 1f       	adc	r20, r20
   1f17e:	55 1f       	adc	r21, r21
   1f180:	7a 95       	dec	r23
   1f182:	d1 f7       	brne	.-12     	; 0x1f178 <uart_set_baudrate+0x20>
   1f184:	60 e0       	ldi	r22, 0x00	; 0
   1f186:	74 e2       	ldi	r23, 0x24	; 36
   1f188:	84 ef       	ldi	r24, 0xF4	; 244
   1f18a:	90 e0       	ldi	r25, 0x00	; 0
   1f18c:	0e 94 cc ff 	call	0x1ff98	; 0x1ff98 <__udivmodsi4>
   1f190:	2f 5f       	subi	r18, 0xFF	; 255
   1f192:	3f 4f       	sbci	r19, 0xFF	; 255
   1f194:	4f 4f       	sbci	r20, 0xFF	; 255
   1f196:	5f 4f       	sbci	r21, 0xFF	; 255
   1f198:	56 95       	lsr	r21
   1f19a:	47 95       	ror	r20
   1f19c:	37 95       	ror	r19
   1f19e:	27 95       	ror	r18
   1f1a0:	d3 c0       	rjmp	.+422    	; 0x1f348 <uart_set_baudrate+0x1f0>
   1f1a2:	80 91 34 01 	lds	r24, 0x0134
   1f1a6:	88 23       	and	r24, r24
   1f1a8:	39 f4       	brne	.+14     	; 0x1f1b8 <uart_set_baudrate+0x60>
   1f1aa:	68 98       	cbi	0x0d, 0	; 13
   1f1ac:	70 9a       	sbi	0x0e, 0	; 14
   1f1ae:	8e b1       	in	r24, 0x0e	; 14
   1f1b0:	69 98       	cbi	0x0d, 1	; 13
   1f1b2:	71 9a       	sbi	0x0e, 1	; 14
   1f1b4:	8e b1       	in	r24, 0x0e	; 14
   1f1b6:	06 c0       	rjmp	.+12     	; 0x1f1c4 <uart_set_baudrate+0x6c>
   1f1b8:	52 98       	cbi	0x0a, 2	; 10
   1f1ba:	5a 9a       	sbi	0x0b, 2	; 11
   1f1bc:	8b b1       	in	r24, 0x0b	; 11
   1f1be:	53 98       	cbi	0x0a, 3	; 10
   1f1c0:	5b 9a       	sbi	0x0b, 3	; 11
   1f1c2:	8b b1       	in	r24, 0x0b	; 11
   1f1c4:	10 92 81 00 	sts	0x0081, r1
   1f1c8:	10 92 80 00 	sts	0x0080, r1
   1f1cc:	10 92 82 00 	sts	0x0082, r1
   1f1d0:	10 92 85 00 	sts	0x0085, r1
   1f1d4:	10 92 84 00 	sts	0x0084, r1
   1f1d8:	10 92 89 00 	sts	0x0089, r1
   1f1dc:	10 92 88 00 	sts	0x0088, r1
   1f1e0:	10 92 8b 00 	sts	0x008B, r1
   1f1e4:	10 92 8a 00 	sts	0x008A, r1
   1f1e8:	10 92 8d 00 	sts	0x008D, r1
   1f1ec:	10 92 8c 00 	sts	0x008C, r1
   1f1f0:	10 92 87 00 	sts	0x0087, r1
   1f1f4:	10 92 86 00 	sts	0x0086, r1
   1f1f8:	0e 94 78 f8 	call	0x1f0f0	; 0x1f0f0 <uart_rx_get_3_data>
   1f1fc:	88 23       	and	r24, r24
   1f1fe:	e1 f3       	breq	.-8      	; 0x1f1f8 <uart_set_baudrate+0xa0>
   1f200:	0e 94 97 f8 	call	0x1f12e	; 0x1f12e <uart_rx_get_data>
   1f204:	88 23       	and	r24, r24
   1f206:	e1 f7       	brne	.-8      	; 0x1f200 <uart_set_baudrate+0xa8>
   1f208:	80 91 81 00 	lds	r24, 0x0081
   1f20c:	88 7f       	andi	r24, 0xF8	; 248
   1f20e:	81 60       	ori	r24, 0x01	; 1
   1f210:	80 93 81 00 	sts	0x0081, r24
   1f214:	0e 94 78 f8 	call	0x1f0f0	; 0x1f0f0 <uart_rx_get_3_data>
   1f218:	88 23       	and	r24, r24
   1f21a:	e1 f3       	breq	.-8      	; 0x1f214 <uart_set_baudrate+0xbc>
   1f21c:	0e 94 97 f8 	call	0x1f12e	; 0x1f12e <uart_rx_get_data>
   1f220:	88 23       	and	r24, r24
   1f222:	e1 f7       	brne	.-8      	; 0x1f21c <uart_set_baudrate+0xc4>
   1f224:	80 91 84 00 	lds	r24, 0x0084
   1f228:	08 2f       	mov	r16, r24
   1f22a:	11 27       	eor	r17, r17
   1f22c:	80 91 85 00 	lds	r24, 0x0085
   1f230:	99 27       	eor	r25, r25
   1f232:	98 2f       	mov	r25, r24
   1f234:	88 27       	eor	r24, r24
   1f236:	08 2b       	or	r16, r24
   1f238:	19 2b       	or	r17, r25
   1f23a:	0e 94 78 f8 	call	0x1f0f0	; 0x1f0f0 <uart_rx_get_3_data>
   1f23e:	88 23       	and	r24, r24
   1f240:	e1 f3       	breq	.-8      	; 0x1f23a <uart_set_baudrate+0xe2>
   1f242:	0e 94 97 f8 	call	0x1f12e	; 0x1f12e <uart_rx_get_data>
   1f246:	88 23       	and	r24, r24
   1f248:	e1 f7       	brne	.-8      	; 0x1f242 <uart_set_baudrate+0xea>
   1f24a:	80 91 84 00 	lds	r24, 0x0084
   1f24e:	c8 2e       	mov	r12, r24
   1f250:	dd 24       	eor	r13, r13
   1f252:	80 91 85 00 	lds	r24, 0x0085
   1f256:	99 27       	eor	r25, r25
   1f258:	f8 2e       	mov	r15, r24
   1f25a:	ee 24       	eor	r14, r14
   1f25c:	0e 94 78 f8 	call	0x1f0f0	; 0x1f0f0 <uart_rx_get_3_data>
   1f260:	88 23       	and	r24, r24
   1f262:	e1 f3       	breq	.-8      	; 0x1f25c <uart_set_baudrate+0x104>
   1f264:	0e 94 97 f8 	call	0x1f12e	; 0x1f12e <uart_rx_get_data>
   1f268:	88 23       	and	r24, r24
   1f26a:	e1 f7       	brne	.-8      	; 0x1f264 <uart_set_baudrate+0x10c>
   1f26c:	80 91 84 00 	lds	r24, 0x0084
   1f270:	c8 2f       	mov	r28, r24
   1f272:	dd 27       	eor	r29, r29
   1f274:	80 91 85 00 	lds	r24, 0x0085
   1f278:	99 27       	eor	r25, r25
   1f27a:	98 2f       	mov	r25, r24
   1f27c:	88 27       	eor	r24, r24
   1f27e:	c8 2b       	or	r28, r24
   1f280:	d9 2b       	or	r29, r25
   1f282:	0e 94 97 f8 	call	0x1f12e	; 0x1f12e <uart_rx_get_data>
   1f286:	88 23       	and	r24, r24
   1f288:	e1 f3       	breq	.-8      	; 0x1f282 <uart_set_baudrate+0x12a>
   1f28a:	20 91 84 00 	lds	r18, 0x0084
   1f28e:	90 91 85 00 	lds	r25, 0x0085
   1f292:	80 91 81 00 	lds	r24, 0x0081
   1f296:	88 7f       	andi	r24, 0xF8	; 248
   1f298:	80 93 81 00 	sts	0x0081, r24
   1f29c:	80 91 34 01 	lds	r24, 0x0134
   1f2a0:	88 23       	and	r24, r24
   1f2a2:	39 f4       	brne	.+14     	; 0x1f2b2 <uart_set_baudrate+0x15a>
   1f2a4:	68 98       	cbi	0x0d, 0	; 13
   1f2a6:	70 98       	cbi	0x0e, 0	; 14
   1f2a8:	8e b1       	in	r24, 0x0e	; 14
   1f2aa:	69 98       	cbi	0x0d, 1	; 13
   1f2ac:	71 98       	cbi	0x0e, 1	; 14
   1f2ae:	8e b1       	in	r24, 0x0e	; 14
   1f2b0:	06 c0       	rjmp	.+12     	; 0x1f2be <uart_set_baudrate+0x166>
   1f2b2:	52 98       	cbi	0x0a, 2	; 10
   1f2b4:	5a 98       	cbi	0x0b, 2	; 11
   1f2b6:	8b b1       	in	r24, 0x0b	; 11
   1f2b8:	53 98       	cbi	0x0a, 3	; 10
   1f2ba:	5b 98       	cbi	0x0b, 3	; 11
   1f2bc:	8b b1       	in	r24, 0x0b	; 11
   1f2be:	33 27       	eor	r19, r19
   1f2c0:	89 2f       	mov	r24, r25
   1f2c2:	99 27       	eor	r25, r25
   1f2c4:	98 2f       	mov	r25, r24
   1f2c6:	88 27       	eor	r24, r24
   1f2c8:	28 2b       	or	r18, r24
   1f2ca:	39 2b       	or	r19, r25
   1f2cc:	2c 1b       	sub	r18, r28
   1f2ce:	3d 0b       	sbc	r19, r29
   1f2d0:	c9 01       	movw	r24, r18
   1f2d2:	88 0f       	add	r24, r24
   1f2d4:	99 1f       	adc	r25, r25
   1f2d6:	36 95       	lsr	r19
   1f2d8:	27 95       	ror	r18
   1f2da:	36 95       	lsr	r19
   1f2dc:	27 95       	ror	r18
   1f2de:	bc 01       	movw	r22, r24
   1f2e0:	62 0f       	add	r22, r18
   1f2e2:	73 1f       	adc	r23, r19
   1f2e4:	60 17       	cp	r22, r16
   1f2e6:	71 07       	cpc	r23, r17
   1f2e8:	08 f4       	brcc	.+2      	; 0x1f2ec <uart_set_baudrate+0x194>
   1f2ea:	50 c0       	rjmp	.+160    	; 0x1f38c <uart_set_baudrate+0x234>
   1f2ec:	82 1b       	sub	r24, r18
   1f2ee:	93 0b       	sbc	r25, r19
   1f2f0:	9c 01       	movw	r18, r24
   1f2f2:	08 17       	cp	r16, r24
   1f2f4:	19 07       	cpc	r17, r25
   1f2f6:	08 f4       	brcc	.+2      	; 0x1f2fa <uart_set_baudrate+0x1a2>
   1f2f8:	49 c0       	rjmp	.+146    	; 0x1f38c <uart_set_baudrate+0x234>
   1f2fa:	c6 01       	movw	r24, r12
   1f2fc:	8e 29       	or	r24, r14
   1f2fe:	9f 29       	or	r25, r15
   1f300:	ac 01       	movw	r20, r24
   1f302:	40 1b       	sub	r20, r16
   1f304:	51 0b       	sbc	r21, r17
   1f306:	64 17       	cp	r22, r20
   1f308:	75 07       	cpc	r23, r21
   1f30a:	08 f4       	brcc	.+2      	; 0x1f30e <uart_set_baudrate+0x1b6>
   1f30c:	3f c0       	rjmp	.+126    	; 0x1f38c <uart_set_baudrate+0x234>
   1f30e:	42 17       	cp	r20, r18
   1f310:	53 07       	cpc	r21, r19
   1f312:	e0 f1       	brcs	.+120    	; 0x1f38c <uart_set_baudrate+0x234>
   1f314:	c8 1b       	sub	r28, r24
   1f316:	d9 0b       	sbc	r29, r25
   1f318:	6c 17       	cp	r22, r28
   1f31a:	7d 07       	cpc	r23, r29
   1f31c:	b8 f1       	brcs	.+110    	; 0x1f38c <uart_set_baudrate+0x234>
   1f31e:	c2 17       	cp	r28, r18
   1f320:	d3 07       	cpc	r29, r19
   1f322:	a0 f1       	brcs	.+104    	; 0x1f38c <uart_set_baudrate+0x234>
   1f324:	98 01       	movw	r18, r16
   1f326:	24 0f       	add	r18, r20
   1f328:	35 1f       	adc	r19, r21
   1f32a:	4c 0f       	add	r20, r28
   1f32c:	5d 1f       	adc	r21, r29
   1f32e:	24 0f       	add	r18, r20
   1f330:	35 1f       	adc	r19, r21
   1f332:	22 0f       	add	r18, r18
   1f334:	33 1f       	adc	r19, r19
   1f336:	76 e0       	ldi	r23, 0x06	; 6
   1f338:	36 95       	lsr	r19
   1f33a:	27 95       	ror	r18
   1f33c:	7a 95       	dec	r23
   1f33e:	e1 f7       	brne	.-8      	; 0x1f338 <uart_set_baudrate+0x1e0>
   1f340:	2f 5f       	subi	r18, 0xFF	; 255
   1f342:	3f 4f       	sbci	r19, 0xFF	; 255
   1f344:	36 95       	lsr	r19
   1f346:	27 95       	ror	r18
   1f348:	21 50       	subi	r18, 0x01	; 1
   1f34a:	30 40       	sbci	r19, 0x00	; 0
   1f34c:	80 91 34 01 	lds	r24, 0x0134
   1f350:	88 23       	and	r24, r24
   1f352:	61 f4       	brne	.+24     	; 0x1f36c <uart_set_baudrate+0x214>
   1f354:	83 2f       	mov	r24, r19
   1f356:	99 27       	eor	r25, r25
   1f358:	80 93 c5 00 	sts	0x00C5, r24
   1f35c:	20 93 c4 00 	sts	0x00C4, r18
   1f360:	80 91 c0 00 	lds	r24, 0x00C0
   1f364:	82 60       	ori	r24, 0x02	; 2
   1f366:	80 93 c0 00 	sts	0x00C0, r24
   1f36a:	0d c0       	rjmp	.+26     	; 0x1f386 <uart_set_baudrate+0x22e>
   1f36c:	81 30       	cpi	r24, 0x01	; 1
   1f36e:	59 f4       	brne	.+22     	; 0x1f386 <uart_set_baudrate+0x22e>
   1f370:	83 2f       	mov	r24, r19
   1f372:	99 27       	eor	r25, r25
   1f374:	80 93 cd 00 	sts	0x00CD, r24
   1f378:	20 93 cc 00 	sts	0x00CC, r18
   1f37c:	80 91 c8 00 	lds	r24, 0x00C8
   1f380:	82 60       	ori	r24, 0x02	; 2
   1f382:	80 93 c8 00 	sts	0x00C8, r24
   1f386:	81 e0       	ldi	r24, 0x01	; 1
   1f388:	90 e0       	ldi	r25, 0x00	; 0
   1f38a:	02 c0       	rjmp	.+4      	; 0x1f390 <uart_set_baudrate+0x238>
   1f38c:	80 e0       	ldi	r24, 0x00	; 0
   1f38e:	90 e0       	ldi	r25, 0x00	; 0
   1f390:	df 91       	pop	r29
   1f392:	cf 91       	pop	r28
   1f394:	1f 91       	pop	r17
   1f396:	0f 91       	pop	r16
   1f398:	ff 90       	pop	r15
   1f39a:	ef 90       	pop	r14
   1f39c:	df 90       	pop	r13
   1f39e:	cf 90       	pop	r12
   1f3a0:	08 95       	ret

0001f3a2 <uart_isp_protocol_init>:
//! @return none
//!
//------------------------------------------------------------------------------
void uart_isp_protocol_init(void)
{
   1f3a2:	10 92 56 02 	sts	0x0256, r1
    isp_select_memory   = MEM_DEFAULT;
    isp_select_page     = PAGE_DEFAULT;
   1f3a6:	10 92 59 02 	sts	0x0259, r1
    isp_start_address   = ADD_DEFAULT;
   1f3aa:	10 92 53 02 	sts	0x0253, r1
   1f3ae:	10 92 52 02 	sts	0x0252, r1
    isp_number_of_bytes = N_DEFAULT;
   1f3b2:	81 e0       	ldi	r24, 0x01	; 1
   1f3b4:	90 e0       	ldi	r25, 0x00	; 0
   1f3b6:	90 93 55 02 	sts	0x0255, r25
   1f3ba:	80 93 54 02 	sts	0x0254, r24
    isp_prog_on_going   = FALSE;
   1f3be:	10 92 2b 01 	sts	0x012B, r1
   1f3c2:	08 95       	ret

0001f3c4 <uart_isp_putchar>:

    //- Init Rx data
//    loc_buf_index = 0;
//    hex_computed_chk = 0;
}

//------------------------------------------------------------------------------
//  @fn uart_isp_protocol_task
//!
//! This function manages the UART ISP PROTOCOL.
//!
//! @warning none
//!
//! @param  none
//!
//! @return 0: Error (not used)
//!         1: Ok (for a new command)
//!
//------------------------------------------------------------------------------
Bool uart_isp_protocol_task(void)
{
U8      u8_temp;
U8      i, j;
U8      hex_switch_code;

    //- Wait for ':' character (HEX_RECORD_MARK)
    while (uart_getchar() != HEX_RECORD_MARK);    
    uart_putchar(HEX_RECORD_MARK);              // Echo
    
    //- Checksum initialization
    hex_computed_chk = 0;
    
    //- Get record lengh
    hex_record_length = uart_isp_getchar();     // Echo performed

    //- Get offset
    hex_offset = (U16)(uart_isp_getchar()) << 8;          // Echo performed
    hex_offset = hex_offset | (U16)(uart_isp_getchar());  // Echo performed
    
    //- Get record type
    hex_record_type = uart_isp_getchar();       // Echo performed

    //- Pre-construction of hex_switch_code
    if(hex_record_type == 0x00)
    {
        hex_switch_code = HEX_TYPE_PROG_DATA;
    }
    else
    {
        hex_switch_code = (U8)(hex_record_length + hex_record_type);
    }

//--- Switch following UART ISP resquest received
    switch (hex_switch_code)
    {

    //- DATA PROGRAMMING (Length = nn, Type = 0x00) ----------------------------
        case HEX_TYPE_PROG_DATA:
            //- Set pointer and size for block to program
            isp_start_address = hex_offset;
            isp_number_of_bytes = (U16)(hex_record_length);
    
            //- Save pointer and size for block programming using
            isp_start_address_copy = isp_start_address;
            isp_number_of_bytes_copy = isp_number_of_bytes;
                
            //- BLOCK PROGRAMMING ----------------------------------------------
                //- Init Rx data
                loc_buf_index = 0;

                //- Rx data
                for (i=0; i<hex_record_length; i++)
                {
                    u8_temp = uart_isp_getchar();       // Echo performed                   
                    local_buffer[loc_buf_index] = u8_temp;
                    loc_buf_index++;
                }

                //- Verify checksum
                u8_temp = uart_isp_getchar();       // Echo performed
                if (hex_computed_chk == 0)
                {
                    u8_temp = isp_prog_block(local_buffer, loc_buf_index);
                    // HEX prtocol defines max Length = 255.
                    // So no 0x00 response from "isp_prog_block()"
                    // only 0x01 (Ok) or 0xFF(error) as response.
                    if (u8_temp == 0xFF)
                    {
                        //- Acknowledge frame = programmation error (ex: SSB cause)
                        uart_isp_send_frame(UART_PROG_ERR);
                    }
                    else
                    {
                        //- Acknowledge frame = command done
                        uart_isp_send_frame(UART_CMD_DONE);                        
                    } 
                    //- Restore pointer and size
                    isp_start_address = isp_start_address_copy;
                    isp_number_of_bytes = isp_number_of_bytes_copy;
                    
                }
                else
                {
                    //- Acknowledge frame = wrong checksum
                    uart_isp_send_frame(UART_WRONG_CHKSUM);
                }

            break;


    //- START APPLICATION (Length = 0x00, Type = 0x01) -------------------------
        case HEX_TYPE_START_APPLI:
            //- Verify checksum
            uart_isp_getchar();       // Echo performed
            if (hex_computed_chk != 0)
            {
                //- Acknowledge frame = wrong ehecksum
                uart_isp_send_frame(UART_WRONG_CHKSUM);
            }
            else
            {
            //- JUMP or RESET --------------------------------------------------            
                //- Hard reset 
                if (hex_offset == 0xFFFF)
                {
                    //uart_isp_send_frame(UART_CMD_DONE);   // Optional                        
                    // Exit from Boot Loader and Hard Reset
                    Hard_reset();       // c.f. at90can_mcu.h included in config.h                
                }
                //- Jump to application @
                else
                {
                    //uart_isp_send_frame(UART_CMD_DONE);   // Optional                        
                    // Exit from Boot Loader and Jump
                    isp_jump_to(hex_offset);
                }
            }
            
            break;


    //- SELECT NEW PAGE (Length = 0x02, Type = 0x02) ---------------------------
        case HEX_TYPE_SEL_PAGE:
            // hex_offset unused !
            j = isp_select_page;    // Saving

            //- Get page
            u8_temp = uart_isp_getchar();       // Echo performed
            isp_select_page = u8_temp >> 4;

            //- PAGE SELECTION -------------------------------------------------            
                //- Get data[1]=0x00
                u8_temp = uart_isp_getchar();       // Echo performed
                if (u8_temp != UART_NEW_PAGE_1)
                {
                    //- Acknowledge frame = unknown command
                    uart_isp_send_frame(UART_UNKNOWN_CMD);
                    isp_select_page = j;    // Restoring
                }
                else
                {
                    //- Verify checksum
                    uart_isp_getchar();       // Echo performed
                    if (hex_computed_chk != 0)
                    {
                        //- Acknowledge frame = wrong checksum
                        uart_isp_send_frame(UART_WRONG_CHKSUM);
                        isp_select_page = j;    // Restoring
                    }
                    else
                    {
                        //- Acknowledge frame = command done
                        uart_isp_send_frame(UART_CMD_DONE);
                    }
                }
            
            break;


    //- SELECT MEMORY and PAGE (Length = 0x02, Type = 0x04) --------------------
        case HEX_TYPE_SEL_MEM_PAGE:
            // hex_offset test
            if (hex_offset != 0x0000)
            {
                //- Acknowledge frame = unknown command
                uart_isp_send_frame(UART_UNKNOWN_CMD);
                break;                  //- Exit from: case ...                    
            }

            i = isp_select_page;      // Saving
            j = isp_select_memory;    // Saving
                                
            //- MEMORY SELECTION -----------------------------------------------            
                //- Get data[0]
                u8_temp = uart_isp_getchar();       // Echo performed
                isp_select_memory = u8_temp;
                
            //- PAGE SELECTION -------------------------------------------------            
                //- Get data[1]
                u8_temp = uart_isp_getchar();       // Echo performed
                isp_select_page = u8_temp;
                
                //- Verify checksum
                uart_isp_getchar();       // Echo performed
                if (hex_computed_chk != 0)
                {
                    //- Acknowledge frame = wrong checksum
                    uart_isp_send_frame(UART_WRONG_CHKSUM);
                    isp_select_memory = i;    // Restoring
                    isp_select_page = j;      // Restoring
                }
                else
                {
                    //- Acknowledge frame = command done
                    uart_isp_send_frame(UART_CMD_DONE);
                }
            
            break;

            
    //- READ/BLANK-CHECK/ERASE MEMORY (Length = 0x05, Type = 0x04, Data[4] ?) --
        case HEX_TYPE_X_DATA:
            // hex_offset test
            if (hex_offset != UART_XD_RD_BC_FE_OFFSET )
            {
                //- Acknowledge frame = unknown command
                uart_isp_send_frame(UART_UNKNOWN_CMD);
                break;                  //- Exit from: case ...                    
            }
                                
            //- GET ALL INFORMATION ... ----------------------------------------            
                //- Rx data and saving in uart_isp_rx_buffer[]
                for (i=0; i<4; i++)
                {
                    u8_temp = uart_isp_getchar();       // Echo performed
                    uart_isp_rx_buffer[i] = u8_temp;
                }
                
                //- Get data[4]
                u8_temp = uart_isp_getchar();       // Echo performed
                if (u8_temp > UART_FULL_ERASE_4)
                {
                    //- Acknowledge frame = unknown command
                    uart_isp_send_frame(UART_UNKNOWN_CMD);
                    break;                  //- Exit from: case ...                    
                }
                hex_switch_code = hex_switch_code + u8_temp;

                 //- Verify checksum
                uart_isp_getchar();       // Echo performed
                if (hex_computed_chk != 0)
                {
                    //- Acknowledge frame = wrong checksum
                    uart_isp_send_frame(UART_WRONG_CHKSUM);
                    break;                  //- Exit from: case ...                    
                }
               
        //- SWITCH FOLLOWING DATA[4] -------------------------------------------
            switch (hex_switch_code)
            {

            //- READ DATA (Length=0x05, Type=0x04, Data[4]=0x00) ---------------
                case HEX_TYPE_READ_DATA:
                    //- Acknowledge command
                    uart_isp_send_frame(UART_CR_LF);
                                
                    //- Set pointer and size for block to program
                    isp_address_range(
                        ( (((U16)uart_isp_rx_buffer[0])<<8) | ((U16)uart_isp_rx_buffer[1]) )
                    ,   ( (((U16)uart_isp_rx_buffer[2])<<8) | ((U16)uart_isp_rx_buffer[3]) ) ) ;
                    
                    //- Save pointer and size
                    isp_start_address_copy = isp_start_address;
                    isp_number_of_bytes_copy = isp_number_of_bytes;

                    while (1)
                    {
                        //- Using "uart_isp_tx_buffer" to communicate with 'uart_isp_send_frame()'
                        uart_isp_tx_buffer[0] = 16;         // Data size
                        uart_isp_tx_buffer[1] = (U8)(isp_start_address >>8);    // msByte of address
                        uart_isp_tx_buffer[2] = (U8)(isp_start_address);        // lsByte of address
                        
                        //- Using "uart_isp_tx_buffer" to store the blocks
                        u8_temp = isp_read_block( &uart_isp_tx_buffer[3] , 16 );
                        
                        if (u8_temp == 0x00)            // Intermediate block
                        {
                            //- Acknowledge frame = read command done
                            uart_isp_send_frame(UART_READ_CMD_DONE);            
                        }
                        else if  (u8_temp == 0x01)      // Last block
                        {
                            uart_isp_tx_buffer[0] = isp_number_of_bytes;    // Data size of the last block
                            //- Acknowledge frame = read command done
                            uart_isp_send_frame(UART_READ_CMD_DONE);            
                            break;  //- Exit from: while(1...
                        }
                        else    //- u8_temp == 0xFF, error (ex: SSB cause)
                        {
                            //- Acknowledge frame = read error (ex: SSB cause)
                            uart_isp_send_frame(UART_READ_ERR);            
                            break;  //- Exit from: while(1...
                        }
                    }

                    //- Restore pointer and size
                    isp_start_address = isp_start_address_copy;
                    isp_number_of_bytes = isp_number_of_bytes_copy;
                    
                break;
                
            //- BLANK CHECK (Length=0x05, Type=0x04, Data[4]=0x01) -------------
                case HEX_TYPE_BLANK_CHECK:
                    //- Set pointer and size for block to program
                    isp_address_range   ( ( (((U16)uart_isp_rx_buffer[0])<<8) | ((U16)uart_isp_rx_buffer[1]) ) , \
                                          ( (((U16)uart_isp_rx_buffer[2])<<8) | ((U16)uart_isp_rx_buffer[3]) ) ) ;
                    
                    //- Save pointer and size
                    isp_start_address_copy = isp_start_address;
                    isp_number_of_bytes_copy = isp_number_of_bytes;

                    if ( isp_blank_check() == FALSE )
                    {
                        //- Using "uart_isp_tx_buffer" to communicate with 'uart_isp_send_frame()'
                        uart_isp_tx_buffer[0] = (U8)(isp_start_address >>8);    // 1st failed address msB
                        uart_isp_tx_buffer[1] = (U8)(isp_start_address);        // 1st failed address lsB
                        //- Acknowledge frame = blank check memory error
                        uart_isp_send_frame(UART_CHK_ERR);            
                    }
                    else
                    {
                        //- Acknowledge frame = command done
                        uart_isp_send_frame(UART_CMD_DONE);            
                    }
                    
                    //- Restore pointer and size
                    isp_start_address = isp_start_address_copy;
                    isp_number_of_bytes = isp_number_of_bytes_copy;

                break;
                
            //- FULL ERASE (Length=0x05, Type=0x04, Data[4]=0x02) --------------
                case HEX_TYPE_FULL_ERASE:
                    // Data[0..3] verification
                    if ( (uart_isp_rx_buffer[0] == UART_FULL_ERASE_0)
                    &&   (uart_isp_rx_buffer[1] == UART_FULL_ERASE_1)
                    &&   (uart_isp_rx_buffer[2] == UART_FULL_ERASE_2)
                    &&   (uart_isp_rx_buffer[3] == UART_FULL_ERASE_3) )
                    {                     
                        //- Erase memory
                        if (isp_memory_erase() == FALSE)
                        {
                            //- Acknowledge frame = erase error (ex: Read Only Memory cause)
                            uart_isp_send_frame(UART_PROG_ERR);
                        }
                        else
                        {
                            //- Acknowledge frame = command done
                            uart_isp_send_frame(UART_CMD_DONE);            
                        }
                    }
                    else
                    {
                        //- Acknowledge frame = unknown command
                        uart_isp_send_frame(UART_UNKNOWN_CMD);
                    }

                break;
                
            //- DEFAULT --------------------------------------------------------
                default:
                    //- Acknowledge frame = unknown command
                    uart_isp_send_frame(UART_UNKNOWN_CMD);
                break;
                                
            }   // 2nd switch (hex_switch_code...
            
        break; // case HEX_TYPE_X_DATA
        
    //- DEFAULT ----------------------------------------------------------------
        default:
            //- Acknowledge frame = unknown command
            uart_isp_send_frame(UART_UNKNOWN_CMD);
        break;

    }   // 1st switch (hex_switch_code...

    return(1);
    
}   // uart_isp_protocol_task...
        
//_____ L O W    L E V E L    F U N C T I O N S ________________________________

//------------------------------------------------------------------------------
//  @fn uart_isp_getchar
//!
//! This function gets from UART 2 hexa ASCII characters and return 1 hexa byte.
//!
//! @warning This function uses 'uart_getchar()'.
//!          This function also uses 'uart_putchar()' for echoing.
//!
//! @param  none 
//!
//! @return  1 hexa character
//!
//------------------------------------------------------------------------------
U8 uart_isp_getchar (void)
{
U8  u8_temp_h, u8_temp_l;
U8  return_byte;

    u8_temp_h = uart_getchar();
    uart_putchar(u8_temp_h);                    // Echo 1st ASCII char
    u8_temp_l = uart_getchar();
    uart_putchar(u8_temp_l);                    // Echo 2nd ASCII char
    
    if (u8_temp_h > '9') u8_temp_h = (u8_temp_h & 0x4F) - 0x07 ;
    return_byte = (u8_temp_h & 0x0F) << 4;
    
    if (u8_temp_l > '9') u8_temp_l = (u8_temp_l & 0x4F) - 0x07 ;
    return_byte = return_byte | (u8_temp_l & 0x0F);

    //- Compute checksum
    hex_computed_chk = (U8)(hex_computed_chk + return_byte);
    
    return(return_byte);
}

//------------------------------------------------------------------------------
//  @fn uart_isp_putchar
//!
//! This function puts on UART 2 hexa ASCII characters from 1 hexa byte.
//!
//! @warning This function uses 'uart_putchar()'.
//!
//! @param  1 hexa character 
//!
//! @return  none
//!
//------------------------------------------------------------------------------
void uart_isp_putchar (U8 simple_byte)
{
   1f3c4:	1f 93       	push	r17
   1f3c6:	18 2f       	mov	r17, r24
    U8  u8_temp;
    
    u8_temp = simple_byte >> 4;
   1f3c8:	82 95       	swap	r24
   1f3ca:	8f 70       	andi	r24, 0x0F	; 15
    if (u8_temp > 9) u8_temp = u8_temp + 0x07 ;
   1f3cc:	8a 30       	cpi	r24, 0x0A	; 10
   1f3ce:	08 f0       	brcs	.+2      	; 0x1f3d2 <uart_isp_putchar+0xe>
   1f3d0:	89 5f       	subi	r24, 0xF9	; 249
    uart_putchar(u8_temp + 0x30);
   1f3d2:	80 5d       	subi	r24, 0xD0	; 208
   1f3d4:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
    
    u8_temp = simple_byte & 0x0F;
   1f3d8:	81 2f       	mov	r24, r17
   1f3da:	8f 70       	andi	r24, 0x0F	; 15
    if (u8_temp > 9) u8_temp = u8_temp + 0x07 ;
   1f3dc:	8a 30       	cpi	r24, 0x0A	; 10
   1f3de:	08 f0       	brcs	.+2      	; 0x1f3e2 <uart_isp_putchar+0x1e>
   1f3e0:	89 5f       	subi	r24, 0xF9	; 249
    uart_putchar(u8_temp + 0x30);
   1f3e2:	80 5d       	subi	r24, 0xD0	; 208
   1f3e4:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f3e8:	1f 91       	pop	r17
   1f3ea:	08 95       	ret

0001f3ec <uart_isp_send_frame>:
}

//------------------------------------------------------------------------------
//  @fn uart_isp_send_frame
//!
//! This function send frames in 'uart_isp_protocol_task()' function.
//! - UART_CMD_DONE         0x00    // '.\r\n'
//! - UART_UNKNOWN_CMD      0x00    // 'K\r\n'
//! - UART_READ_CMD_DONE    0x01    // 'address=data(16-byte)\r\n'
//! - UART_WRONG_CHKSUM     0x02    // 'X\r\n'
//! - UART_CHK_ERR          0x03    // '1st_failling_add\r\n'
//! - UART_READ_ERR         0x04    // 'L\r\n'
//! - UART_PROG_ERR         0x05    // 'P\r\n'
//! - UART_CR_LF            0xFF    // '\r\n'
//!
//! @warning none
//!
//! @param From 0x00 to 0x05 & 0xFF (see above or in 'uart_isp_protocol_task.h')
//!
//! @return  none
//!
//------------------------------------------------------------------------------
void uart_isp_send_frame(U8 frame_type)
{
   1f3ec:	cf 93       	push	r28
   1f3ee:	df 93       	push	r29
U8  i;

    switch (frame_type)
   1f3f0:	83 30       	cpi	r24, 0x03	; 3
   1f3f2:	79 f1       	breq	.+94     	; 0x1f452 <uart_isp_send_frame+0x66>
   1f3f4:	84 30       	cpi	r24, 0x04	; 4
   1f3f6:	28 f4       	brcc	.+10     	; 0x1f402 <uart_isp_send_frame+0x16>
   1f3f8:	81 30       	cpi	r24, 0x01	; 1
   1f3fa:	71 f0       	breq	.+28     	; 0x1f418 <uart_isp_send_frame+0x2c>
   1f3fc:	82 30       	cpi	r24, 0x02	; 2
   1f3fe:	70 f4       	brcc	.+28     	; 0x1f41c <uart_isp_send_frame+0x30>
   1f400:	09 c0       	rjmp	.+18     	; 0x1f414 <uart_isp_send_frame+0x28>
   1f402:	85 30       	cpi	r24, 0x05	; 5
   1f404:	89 f1       	breq	.+98     	; 0x1f468 <uart_isp_send_frame+0x7c>
   1f406:	85 30       	cpi	r24, 0x05	; 5
   1f408:	30 f1       	brcs	.+76     	; 0x1f456 <uart_isp_send_frame+0x6a>
   1f40a:	86 30       	cpi	r24, 0x06	; 6
   1f40c:	79 f1       	breq	.+94     	; 0x1f46c <uart_isp_send_frame+0x80>
   1f40e:	8f 3f       	cpi	r24, 0xFF	; 255
   1f410:	b1 f5       	brne	.+108    	; 0x1f47e <uart_isp_send_frame+0x92>
   1f412:	2f c0       	rjmp	.+94     	; 0x1f472 <uart_isp_send_frame+0x86>
    {
    
    //- ACKNOWLEDGE FRAME = COMMAND DONE ---------------------------------------
        case UART_CMD_DONE:
            uart_putchar('.'); uart_isp_send_frame(UART_CR_LF);    
   1f414:	8e e2       	ldi	r24, 0x2E	; 46
   1f416:	2b c0       	rjmp	.+86     	; 0x1f46e <uart_isp_send_frame+0x82>
        break;

    //- ACKNOWLEDGE FRAME = UNKNOWN COMMAND ------------------------------------
        case UART_UNKNOWN_CMD:
            uart_putchar('K'); uart_isp_send_frame(UART_CR_LF);    
   1f418:	8b e4       	ldi	r24, 0x4B	; 75
   1f41a:	29 c0       	rjmp	.+82     	; 0x1f46e <uart_isp_send_frame+0x82>
        break;

    //- ACKNOWLEDGE FRAME = READ COMMAND DONE ----------------------------------
        case UART_READ_CMD_DONE:
            uart_isp_putchar(uart_isp_tx_buffer[1]);    // msByte of address    
   1f41c:	80 91 3f 01 	lds	r24, 0x013F
   1f420:	0e 94 e2 f9 	call	0x1f3c4	; 0x1f3c4 <uart_isp_putchar>
            uart_isp_putchar(uart_isp_tx_buffer[2]);    // lsByte of address    
   1f424:	80 91 40 01 	lds	r24, 0x0140
   1f428:	0e 94 e2 f9 	call	0x1f3c4	; 0x1f3c4 <uart_isp_putchar>
      
            uart_putchar('=');
   1f42c:	8d e3       	ldi	r24, 0x3D	; 61
   1f42e:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f432:	c0 e0       	ldi	r28, 0x00	; 0
   1f434:	d0 e0       	ldi	r29, 0x00	; 0
   1f436:	06 c0       	rjmp	.+12     	; 0x1f444 <uart_isp_send_frame+0x58>
        
            for (i=0; i< uart_isp_tx_buffer[0]; i++)
            {
                uart_isp_putchar(uart_isp_tx_buffer[i+3]);
   1f438:	ff 27       	eor	r31, r31
   1f43a:	e2 5c       	subi	r30, 0xC2	; 194
   1f43c:	fe 4f       	sbci	r31, 0xFE	; 254
   1f43e:	83 81       	ldd	r24, Z+3	; 0x03
   1f440:	0e 94 e2 f9 	call	0x1f3c4	; 0x1f3c4 <uart_isp_putchar>
   1f444:	ec 2f       	mov	r30, r28
   1f446:	21 96       	adiw	r28, 0x01	; 1
   1f448:	80 91 3e 01 	lds	r24, 0x013E
   1f44c:	e8 17       	cp	r30, r24
   1f44e:	a0 f3       	brcs	.-24     	; 0x1f438 <uart_isp_send_frame+0x4c>
   1f450:	10 c0       	rjmp	.+32     	; 0x1f472 <uart_isp_send_frame+0x86>
            }        
            uart_isp_send_frame(UART_CR_LF);    
        break;
        
    //- ACKNOWLEDGE FRAME = WRONG CHECKSUM -------------------------------------
        case UART_WRONG_CHKSUM:
            uart_putchar('X'); uart_isp_send_frame(UART_CR_LF);    
   1f452:	88 e5       	ldi	r24, 0x58	; 88
   1f454:	0c c0       	rjmp	.+24     	; 0x1f46e <uart_isp_send_frame+0x82>
        break;

    //- ACKNOWLEDGE FRAME = BLANK CHECK MEMORY ERROR ---------------------------
        case UART_CHK_ERR:
            uart_isp_putchar(uart_isp_tx_buffer[0]);    // msByte of address    
   1f456:	80 91 3e 01 	lds	r24, 0x013E
   1f45a:	0e 94 e2 f9 	call	0x1f3c4	; 0x1f3c4 <uart_isp_putchar>
            uart_isp_putchar(uart_isp_tx_buffer[1]);    // lsByte of address    
   1f45e:	80 91 3f 01 	lds	r24, 0x013F
   1f462:	0e 94 e2 f9 	call	0x1f3c4	; 0x1f3c4 <uart_isp_putchar>
   1f466:	05 c0       	rjmp	.+10     	; 0x1f472 <uart_isp_send_frame+0x86>
      
            uart_isp_send_frame(UART_CR_LF);    
        break;
        
    //- ACKNOWLEDGE FRAME = READ MEMORY ERROR (EX: SSB CAUSE) ------------------
        case UART_READ_ERR:
            uart_putchar('L'); uart_isp_send_frame(UART_CR_LF);    
   1f468:	8c e4       	ldi	r24, 0x4C	; 76
   1f46a:	01 c0       	rjmp	.+2      	; 0x1f46e <uart_isp_send_frame+0x82>
        break;

    //- ACKNOWLEDGE FRAME = PROGRAM MEMORY ERROR (EX: SSB CAUSE) ---------------
        case UART_PROG_ERR:
            uart_putchar('P'); uart_isp_send_frame(UART_CR_LF);    
   1f46c:	80 e5       	ldi	r24, 0x50	; 80
   1f46e:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
        break;
        
    //- PUTCHAR CR and LF ------------------------------------------------------
        case UART_CR_LF:
            uart_putchar('\r'); uart_putchar('\n');    
   1f472:	8d e0       	ldi	r24, 0x0D	; 13
   1f474:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f478:	8a e0       	ldi	r24, 0x0A	; 10
   1f47a:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f47e:	df 91       	pop	r29
   1f480:	cf 91       	pop	r28
   1f482:	08 95       	ret

0001f484 <uart_isp_getchar>:
   1f484:	0f 93       	push	r16
   1f486:	1f 93       	push	r17
   1f488:	0e 94 4a fc 	call	0x1f894	; 0x1f894 <uart_getchar>
   1f48c:	08 2f       	mov	r16, r24
   1f48e:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f492:	0e 94 4a fc 	call	0x1f894	; 0x1f894 <uart_getchar>
   1f496:	18 2f       	mov	r17, r24
   1f498:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f49c:	0a 33       	cpi	r16, 0x3A	; 58
   1f49e:	10 f0       	brcs	.+4      	; 0x1f4a4 <uart_isp_getchar+0x20>
   1f4a0:	0f 74       	andi	r16, 0x4F	; 79
   1f4a2:	07 50       	subi	r16, 0x07	; 7
   1f4a4:	1a 33       	cpi	r17, 0x3A	; 58
   1f4a6:	10 f0       	brcs	.+4      	; 0x1f4ac <uart_isp_getchar+0x28>
   1f4a8:	1f 74       	andi	r17, 0x4F	; 79
   1f4aa:	17 50       	subi	r17, 0x07	; 7
   1f4ac:	80 2f       	mov	r24, r16
   1f4ae:	82 95       	swap	r24
   1f4b0:	80 7f       	andi	r24, 0xF0	; 240
   1f4b2:	1f 70       	andi	r17, 0x0F	; 15
   1f4b4:	81 2b       	or	r24, r17
   1f4b6:	90 91 51 01 	lds	r25, 0x0151
   1f4ba:	98 0f       	add	r25, r24
   1f4bc:	90 93 51 01 	sts	0x0151, r25
   1f4c0:	99 27       	eor	r25, r25
   1f4c2:	1f 91       	pop	r17
   1f4c4:	0f 91       	pop	r16
   1f4c6:	08 95       	ret

0001f4c8 <uart_isp_protocol_task>:
   1f4c8:	0f 93       	push	r16
   1f4ca:	1f 93       	push	r17
   1f4cc:	cf 93       	push	r28
   1f4ce:	df 93       	push	r29
   1f4d0:	0e 94 4a fc 	call	0x1f894	; 0x1f894 <uart_getchar>
   1f4d4:	8a 33       	cpi	r24, 0x3A	; 58
   1f4d6:	e1 f7       	brne	.-8      	; 0x1f4d0 <uart_isp_protocol_task+0x8>
   1f4d8:	0e 94 2f fc 	call	0x1f85e	; 0x1f85e <uart_putchar>
   1f4dc:	10 92 51 01 	sts	0x0151, r1
   1f4e0:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f4e4:	80 93 37 01 	sts	0x0137, r24
   1f4e8:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f4ec:	08 2f       	mov	r16, r24
   1f4ee:	11 27       	eor	r17, r17
   1f4f0:	10 2f       	mov	r17, r16
   1f4f2:	00 27       	eor	r16, r16
   1f4f4:	10 93 36 01 	sts	0x0136, r17
   1f4f8:	00 93 35 01 	sts	0x0135, r16
   1f4fc:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f500:	99 27       	eor	r25, r25
   1f502:	08 2b       	or	r16, r24
   1f504:	19 2b       	or	r17, r25
   1f506:	10 93 36 01 	sts	0x0136, r17
   1f50a:	00 93 35 01 	sts	0x0135, r16
   1f50e:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f512:	80 93 38 01 	sts	0x0138, r24
   1f516:	88 23       	and	r24, r24
   1f518:	a9 f0       	breq	.+42     	; 0x1f544 <uart_isp_protocol_task+0x7c>
   1f51a:	90 91 37 01 	lds	r25, 0x0137
   1f51e:	98 0f       	add	r25, r24
   1f520:	94 30       	cpi	r25, 0x04	; 4
   1f522:	09 f4       	brne	.+2      	; 0x1f526 <uart_isp_protocol_task+0x5e>
   1f524:	6f c0       	rjmp	.+222    	; 0x1f604 <uart_isp_protocol_task+0x13c>
   1f526:	95 30       	cpi	r25, 0x05	; 5
   1f528:	30 f4       	brcc	.+12     	; 0x1f536 <uart_isp_protocol_task+0x6e>
   1f52a:	99 23       	and	r25, r25
   1f52c:	59 f0       	breq	.+22     	; 0x1f544 <uart_isp_protocol_task+0x7c>
   1f52e:	91 30       	cpi	r25, 0x01	; 1
   1f530:	09 f0       	breq	.+2      	; 0x1f534 <uart_isp_protocol_task+0x6c>
   1f532:	7d c1       	rjmp	.+762    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f534:	4f c0       	rjmp	.+158    	; 0x1f5d4 <uart_isp_protocol_task+0x10c>
   1f536:	96 30       	cpi	r25, 0x06	; 6
   1f538:	09 f4       	brne	.+2      	; 0x1f53c <uart_isp_protocol_task+0x74>
   1f53a:	7d c0       	rjmp	.+250    	; 0x1f636 <uart_isp_protocol_task+0x16e>
   1f53c:	99 30       	cpi	r25, 0x09	; 9
   1f53e:	09 f0       	breq	.+2      	; 0x1f542 <uart_isp_protocol_task+0x7a>
   1f540:	76 c1       	rjmp	.+748    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f542:	9b c0       	rjmp	.+310    	; 0x1f67a <uart_isp_protocol_task+0x1b2>
   1f544:	20 91 35 01 	lds	r18, 0x0135
   1f548:	30 91 36 01 	lds	r19, 0x0136
   1f54c:	30 93 53 02 	sts	0x0253, r19
   1f550:	20 93 52 02 	sts	0x0252, r18
   1f554:	80 91 37 01 	lds	r24, 0x0137
   1f558:	99 27       	eor	r25, r25
   1f55a:	90 93 55 02 	sts	0x0255, r25
   1f55e:	80 93 54 02 	sts	0x0254, r24
   1f562:	30 93 5d 02 	sts	0x025D, r19
   1f566:	20 93 5c 02 	sts	0x025C, r18
   1f56a:	90 93 5b 02 	sts	0x025B, r25
   1f56e:	80 93 5a 02 	sts	0x025A, r24
   1f572:	10 92 58 02 	sts	0x0258, r1
   1f576:	10 92 57 02 	sts	0x0257, r1
   1f57a:	c0 e0       	ldi	r28, 0x00	; 0
   1f57c:	d0 e0       	ldi	r29, 0x00	; 0
   1f57e:	10 c0       	rjmp	.+32     	; 0x1f5a0 <uart_isp_protocol_task+0xd8>
   1f580:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f584:	20 91 57 02 	lds	r18, 0x0257
   1f588:	30 91 58 02 	lds	r19, 0x0258
   1f58c:	f9 01       	movw	r30, r18
   1f58e:	ee 5a       	subi	r30, 0xAE	; 174
   1f590:	fe 4f       	sbci	r31, 0xFE	; 254
   1f592:	80 83       	st	Z, r24
   1f594:	2f 5f       	subi	r18, 0xFF	; 255
   1f596:	3f 4f       	sbci	r19, 0xFF	; 255
   1f598:	30 93 58 02 	sts	0x0258, r19
   1f59c:	20 93 57 02 	sts	0x0257, r18
   1f5a0:	9c 2f       	mov	r25, r28
   1f5a2:	21 96       	adiw	r28, 0x01	; 1
   1f5a4:	80 91 37 01 	lds	r24, 0x0137
   1f5a8:	98 17       	cp	r25, r24
   1f5aa:	50 f3       	brcs	.-44     	; 0x1f580 <uart_isp_protocol_task+0xb8>
   1f5ac:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f5b0:	80 91 51 01 	lds	r24, 0x0151
   1f5b4:	88 23       	and	r24, r24
   1f5b6:	09 f0       	breq	.+2      	; 0x1f5ba <uart_isp_protocol_task+0xf2>
   1f5b8:	7c c0       	rjmp	.+248    	; 0x1f6b2 <uart_isp_protocol_task+0x1ea>
   1f5ba:	60 91 57 02 	lds	r22, 0x0257
   1f5be:	70 91 58 02 	lds	r23, 0x0258
   1f5c2:	82 e5       	ldi	r24, 0x52	; 82
   1f5c4:	91 e0       	ldi	r25, 0x01	; 1
   1f5c6:	0e 94 2b fd 	call	0x1fa56	; 0x1fa56 <isp_prog_block>
   1f5ca:	8f 3f       	cpi	r24, 0xFF	; 255
   1f5cc:	09 f0       	breq	.+2      	; 0x1f5d0 <uart_isp_protocol_task+0x108>
   1f5ce:	03 c1       	rjmp	.+518    	; 0x1f7d6 <uart_isp_protocol_task+0x30e>
   1f5d0:	86 e0       	ldi	r24, 0x06	; 6
   1f5d2:	02 c1       	rjmp	.+516    	; 0x1f7d8 <uart_isp_protocol_task+0x310>
   1f5d4:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f5d8:	80 91 51 01 	lds	r24, 0x0151
   1f5dc:	88 23       	and	r24, r24
   1f5de:	09 f0       	breq	.+2      	; 0x1f5e2 <uart_isp_protocol_task+0x11a>
   1f5e0:	68 c0       	rjmp	.+208    	; 0x1f6b2 <uart_isp_protocol_task+0x1ea>
   1f5e2:	80 91 35 01 	lds	r24, 0x0135
   1f5e6:	90 91 36 01 	lds	r25, 0x0136
   1f5ea:	2f ef       	ldi	r18, 0xFF	; 255
   1f5ec:	8f 3f       	cpi	r24, 0xFF	; 255
   1f5ee:	92 07       	cpc	r25, r18
   1f5f0:	31 f4       	brne	.+12     	; 0x1f5fe <uart_isp_protocol_task+0x136>
   1f5f2:	80 91 60 00 	lds	r24, 0x0060
   1f5f6:	88 60       	ori	r24, 0x08	; 8
   1f5f8:	80 93 60 00 	sts	0x0060, r24
   1f5fc:	ff cf       	rjmp	.-2      	; 0x1f5fc <uart_isp_protocol_task+0x134>
   1f5fe:	0e 94 f2 fc 	call	0x1f9e4	; 0x1f9e4 <isp_jump_to>
   1f602:	18 c1       	rjmp	.+560    	; 0x1f834 <uart_isp_protocol_task+0x36c>
   1f604:	00 91 59 02 	lds	r16, 0x0259
   1f608:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f60c:	82 95       	swap	r24
   1f60e:	8f 70       	andi	r24, 0x0F	; 15
   1f610:	80 93 59 02 	sts	0x0259, r24
   1f614:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f618:	88 23       	and	r24, r24
   1f61a:	11 f0       	breq	.+4      	; 0x1f620 <uart_isp_protocol_task+0x158>
   1f61c:	81 e0       	ldi	r24, 0x01	; 1
   1f61e:	08 c0       	rjmp	.+16     	; 0x1f630 <uart_isp_protocol_task+0x168>
   1f620:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f624:	80 91 51 01 	lds	r24, 0x0151
   1f628:	88 23       	and	r24, r24
   1f62a:	09 f4       	brne	.+2      	; 0x1f62e <uart_isp_protocol_task+0x166>
   1f62c:	fe c0       	rjmp	.+508    	; 0x1f82a <uart_isp_protocol_task+0x362>
   1f62e:	83 e0       	ldi	r24, 0x03	; 3
   1f630:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <uart_isp_send_frame>
   1f634:	1f c0       	rjmp	.+62     	; 0x1f674 <uart_isp_protocol_task+0x1ac>
   1f636:	80 91 35 01 	lds	r24, 0x0135
   1f63a:	90 91 36 01 	lds	r25, 0x0136
   1f63e:	89 2b       	or	r24, r25
   1f640:	09 f0       	breq	.+2      	; 0x1f644 <uart_isp_protocol_task+0x17c>
   1f642:	f5 c0       	rjmp	.+490    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f644:	10 91 59 02 	lds	r17, 0x0259
   1f648:	00 91 56 02 	lds	r16, 0x0256
   1f64c:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f650:	80 93 56 02 	sts	0x0256, r24
   1f654:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f658:	80 93 59 02 	sts	0x0259, r24
   1f65c:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f660:	80 91 51 01 	lds	r24, 0x0151
   1f664:	88 23       	and	r24, r24
   1f666:	09 f4       	brne	.+2      	; 0x1f66a <uart_isp_protocol_task+0x1a2>
   1f668:	e0 c0       	rjmp	.+448    	; 0x1f82a <uart_isp_protocol_task+0x362>
   1f66a:	83 e0       	ldi	r24, 0x03	; 3
   1f66c:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <uart_isp_send_frame>
   1f670:	10 93 56 02 	sts	0x0256, r17
   1f674:	00 93 59 02 	sts	0x0259, r16
   1f678:	dd c0       	rjmp	.+442    	; 0x1f834 <uart_isp_protocol_task+0x36c>
   1f67a:	80 91 35 01 	lds	r24, 0x0135
   1f67e:	90 91 36 01 	lds	r25, 0x0136
   1f682:	89 2b       	or	r24, r25
   1f684:	09 f0       	breq	.+2      	; 0x1f688 <uart_isp_protocol_task+0x1c0>
   1f686:	d3 c0       	rjmp	.+422    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f688:	c9 e3       	ldi	r28, 0x39	; 57
   1f68a:	d1 e0       	ldi	r29, 0x01	; 1
   1f68c:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f690:	89 93       	st	Y+, r24
   1f692:	81 e0       	ldi	r24, 0x01	; 1
   1f694:	cd 33       	cpi	r28, 0x3D	; 61
   1f696:	d8 07       	cpc	r29, r24
   1f698:	c9 f7       	brne	.-14     	; 0x1f68c <uart_isp_protocol_task+0x1c4>
   1f69a:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f69e:	08 2f       	mov	r16, r24
   1f6a0:	83 30       	cpi	r24, 0x03	; 3
   1f6a2:	08 f0       	brcs	.+2      	; 0x1f6a6 <uart_isp_protocol_task+0x1de>
   1f6a4:	c4 c0       	rjmp	.+392    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f6a6:	0e 94 42 fa 	call	0x1f484	; 0x1f484 <uart_isp_getchar>
   1f6aa:	80 91 51 01 	lds	r24, 0x0151
   1f6ae:	88 23       	and	r24, r24
   1f6b0:	11 f0       	breq	.+4      	; 0x1f6b6 <uart_isp_protocol_task+0x1ee>
   1f6b2:	83 e0       	ldi	r24, 0x03	; 3
   1f6b4:	bd c0       	rjmp	.+378    	; 0x1f830 <uart_isp_protocol_task+0x368>
   1f6b6:	80 2f       	mov	r24, r16
   1f6b8:	87 5f       	subi	r24, 0xF7	; 247
   1f6ba:	89 30       	cpi	r24, 0x09	; 9
   1f6bc:	51 f0       	breq	.+20     	; 0x1f6d2 <uart_isp_protocol_task+0x20a>
   1f6be:	89 30       	cpi	r24, 0x09	; 9
   1f6c0:	08 f4       	brcc	.+2      	; 0x1f6c4 <uart_isp_protocol_task+0x1fc>
   1f6c2:	b5 c0       	rjmp	.+362    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f6c4:	8a 30       	cpi	r24, 0x0A	; 10
   1f6c6:	09 f4       	brne	.+2      	; 0x1f6ca <uart_isp_protocol_task+0x202>
   1f6c8:	50 c0       	rjmp	.+160    	; 0x1f76a <uart_isp_protocol_task+0x2a2>
   1f6ca:	8b 30       	cpi	r24, 0x0B	; 11
   1f6cc:	09 f0       	breq	.+2      	; 0x1f6d0 <uart_isp_protocol_task+0x208>
   1f6ce:	af c0       	rjmp	.+350    	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f6d0:	96 c0       	rjmp	.+300    	; 0x1f7fe <uart_isp_protocol_task+0x336>
   1f6d2:	8f ef       	ldi	r24, 0xFF	; 255
   1f6d4:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <uart_isp_send_frame>
   1f6d8:	60 91 3b 01 	lds	r22, 0x013B
   1f6dc:	77 27       	eor	r23, r23
   1f6de:	76 2f       	mov	r23, r22
   1f6e0:	66 27       	eor	r22, r22
   1f6e2:	80 91 3c 01 	lds	r24, 0x013C
   1f6e6:	99 27       	eor	r25, r25
   1f6e8:	68 2b       	or	r22, r24
   1f6ea:	79 2b       	or	r23, r25
   1f6ec:	80 91 39 01 	lds	r24, 0x0139
   1f6f0:	99 27       	eor	r25, r25
   1f6f2:	98 2f       	mov	r25, r24
   1f6f4:	88 27       	eor	r24, r24
   1f6f6:	20 91 3a 01 	lds	r18, 0x013A
   1f6fa:	33 27       	eor	r19, r19
   1f6fc:	82 2b       	or	r24, r18
   1f6fe:	93 2b       	or	r25, r19
   1f700:	0e 94 02 fd 	call	0x1fa04	; 0x1fa04 <isp_address_range>
   1f704:	80 91 52 02 	lds	r24, 0x0252
   1f708:	90 91 53 02 	lds	r25, 0x0253
   1f70c:	90 93 5d 02 	sts	0x025D, r25
   1f710:	80 93 5c 02 	sts	0x025C, r24
   1f714:	80 91 54 02 	lds	r24, 0x0254
   1f718:	90 91 55 02 	lds	r25, 0x0255
   1f71c:	90 93 5b 02 	sts	0x025B, r25
   1f720:	80 93 5a 02 	sts	0x025A, r24
   1f724:	80 e1       	ldi	r24, 0x10	; 16
   1f726:	80 93 3e 01 	sts	0x013E, r24
   1f72a:	20 91 52 02 	lds	r18, 0x0252
   1f72e:	30 91 53 02 	lds	r19, 0x0253
   1f732:	83 2f       	mov	r24, r19
   1f734:	99 27       	eor	r25, r25
   1f736:	80 93 3f 01 	sts	0x013F, r24
   1f73a:	20 93 40 01 	sts	0x0140, r18
   1f73e:	60 e1       	ldi	r22, 0x10	; 16
   1f740:	70 e0       	ldi	r23, 0x00	; 0
   1f742:	81 e4       	ldi	r24, 0x41	; 65
   1f744:	91 e0       	ldi	r25, 0x01	; 1
   1f746:	0e 94 18 fe 	call	0x1fc30	; 0x1fc30 <isp_read_block>
   1f74a:	88 23       	and	r24, r24
   1f74c:	21 f4       	brne	.+8      	; 0x1f756 <uart_isp_protocol_task+0x28e>
   1f74e:	82 e0       	ldi	r24, 0x02	; 2
   1f750:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <uart_isp_send_frame>
   1f754:	e7 cf       	rjmp	.-50     	; 0x1f724 <uart_isp_protocol_task+0x25c>
   1f756:	81 30       	cpi	r24, 0x01	; 1
   1f758:	31 f4       	brne	.+12     	; 0x1f766 <uart_isp_protocol_task+0x29e>
   1f75a:	80 91 54 02 	lds	r24, 0x0254
   1f75e:	80 93 3e 01 	sts	0x013E, r24
   1f762:	82 e0       	ldi	r24, 0x02	; 2
   1f764:	39 c0       	rjmp	.+114    	; 0x1f7d8 <uart_isp_protocol_task+0x310>
   1f766:	85 e0       	ldi	r24, 0x05	; 5
   1f768:	37 c0       	rjmp	.+110    	; 0x1f7d8 <uart_isp_protocol_task+0x310>
   1f76a:	60 91 3b 01 	lds	r22, 0x013B
   1f76e:	77 27       	eor	r23, r23
   1f770:	76 2f       	mov	r23, r22
   1f772:	66 27       	eor	r22, r22
   1f774:	80 91 3c 01 	lds	r24, 0x013C
   1f778:	99 27       	eor	r25, r25
   1f77a:	68 2b       	or	r22, r24
   1f77c:	79 2b       	or	r23, r25
   1f77e:	80 91 39 01 	lds	r24, 0x0139
   1f782:	99 27       	eor	r25, r25
   1f784:	98 2f       	mov	r25, r24
   1f786:	88 27       	eor	r24, r24
   1f788:	20 91 3a 01 	lds	r18, 0x013A
   1f78c:	33 27       	eor	r19, r19
   1f78e:	82 2b       	or	r24, r18
   1f790:	93 2b       	or	r25, r19
   1f792:	0e 94 02 fd 	call	0x1fa04	; 0x1fa04 <isp_address_range>
   1f796:	80 91 52 02 	lds	r24, 0x0252
   1f79a:	90 91 53 02 	lds	r25, 0x0253
   1f79e:	90 93 5d 02 	sts	0x025D, r25
   1f7a2:	80 93 5c 02 	sts	0x025C, r24
   1f7a6:	80 91 54 02 	lds	r24, 0x0254
   1f7aa:	90 91 55 02 	lds	r25, 0x0255
   1f7ae:	90 93 5b 02 	sts	0x025B, r25
   1f7b2:	80 93 5a 02 	sts	0x025A, r24
   1f7b6:	0e 94 a7 fd 	call	0x1fb4e	; 0x1fb4e <isp_blank_check>
   1f7ba:	88 23       	and	r24, r24
   1f7bc:	61 f4       	brne	.+24     	; 0x1f7d6 <uart_isp_protocol_task+0x30e>
   1f7be:	20 91 52 02 	lds	r18, 0x0252
   1f7c2:	30 91 53 02 	lds	r19, 0x0253
   1f7c6:	83 2f       	mov	r24, r19
   1f7c8:	99 27       	eor	r25, r25
   1f7ca:	80 93 3e 01 	sts	0x013E, r24
   1f7ce:	20 93 3f 01 	sts	0x013F, r18
   1f7d2:	84 e0       	ldi	r24, 0x04	; 4
   1f7d4:	01 c0       	rjmp	.+2      	; 0x1f7d8 <uart_isp_protocol_task+0x310>
   1f7d6:	80 e0       	ldi	r24, 0x00	; 0
   1f7d8:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <uart_isp_send_frame>
   1f7dc:	80 91 5c 02 	lds	r24, 0x025C
   1f7e0:	90 91 5d 02 	lds	r25, 0x025D
   1f7e4:	90 93 53 02 	sts	0x0253, r25
   1f7e8:	80 93 52 02 	sts	0x0252, r24
   1f7ec:	80 91 5a 02 	lds	r24, 0x025A
   1f7f0:	90 91 5b 02 	lds	r25, 0x025B
   1f7f4:	90 93 55 02 	sts	0x0255, r25
   1f7f8:	80 93 54 02 	sts	0x0254, r24
   1f7fc:	1b c0       	rjmp	.+54     	; 0x1f834 <uart_isp_protocol_task+0x36c>
   1f7fe:	80 91 39 01 	lds	r24, 0x0139
   1f802:	88 23       	and	r24, r24
   1f804:	a1 f4       	brne	.+40     	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f806:	80 91 3a 01 	lds	r24, 0x013A
   1f80a:	8f 3f       	cpi	r24, 0xFF	; 255
   1f80c:	81 f4       	brne	.+32     	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f80e:	80 91 3b 01 	lds	r24, 0x013B
   1f812:	88 23       	and	r24, r24
   1f814:	61 f4       	brne	.+24     	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f816:	80 91 3c 01 	lds	r24, 0x013C
   1f81a:	88 23       	and	r24, r24
   1f81c:	41 f4       	brne	.+16     	; 0x1f82e <uart_isp_protocol_task+0x366>
   1f81e:	0e 94 9f ff 	call	0x1ff3e	; 0x1ff3e <isp_memory_erase>
   1f822:	88 23       	and	r24, r24
   1f824:	11 f4       	brne	.+4      	; 0x1f82a <uart_isp_protocol_task+0x362>
   1f826:	86 e0       	ldi	r24, 0x06	; 6
   1f828:	03 c0       	rjmp	.+6      	; 0x1f830 <uart_isp_protocol_task+0x368>
   1f82a:	80 e0       	ldi	r24, 0x00	; 0
   1f82c:	01 c0       	rjmp	.+2      	; 0x1f830 <uart_isp_protocol_task+0x368>
   1f82e:	81 e0       	ldi	r24, 0x01	; 1
   1f830:	0e 94 f6 f9 	call	0x1f3ec	; 0x1f3ec <uart_isp_send_frame>
   1f834:	81 e0       	ldi	r24, 0x01	; 1
   1f836:	90 e0       	ldi	r25, 0x00	; 0
   1f838:	df 91       	pop	r29
   1f83a:	cf 91       	pop	r28
   1f83c:	1f 91       	pop	r17
   1f83e:	0f 91       	pop	r16
   1f840:	08 95       	ret

0001f842 <uart_test_hit>:
//!         ==1: A character has been received
//!
//------------------------------------------------------------------------------
U8 uart_test_hit (void)
{
   1f842:	80 91 34 01 	lds	r24, 0x0134
   1f846:	88 23       	and	r24, r24
   1f848:	19 f4       	brne	.+6      	; 0x1f850 <uart_test_hit+0xe>
    return (Uart_rx_ready());
   1f84a:	80 91 c0 00 	lds	r24, 0x00C0
   1f84e:	02 c0       	rjmp	.+4      	; 0x1f854 <uart_test_hit+0x12>
   1f850:	80 91 c8 00 	lds	r24, 0x00C8
   1f854:	88 1f       	adc	r24, r24
   1f856:	88 27       	eor	r24, r24
   1f858:	88 1f       	adc	r24, r24
}
   1f85a:	99 27       	eor	r25, r25
   1f85c:	08 95       	ret

0001f85e <uart_putchar>:

//------------------------------------------------------------------------------
//  @fn uart_putchar
//!
//! Send a character on the UART peripheral.
//!
//! @warning none
//!
//! @param  character to send
//!
//! @return character sent
//!
//------------------------------------------------------------------------------
U8 uart_putchar (U8 ch)
{
   1f85e:	98 2f       	mov	r25, r24
    while(!Uart_tx_ready());
   1f860:	20 91 34 01 	lds	r18, 0x0134
   1f864:	22 23       	and	r18, r18
   1f866:	29 f4       	brne	.+10     	; 0x1f872 <uart_putchar+0x14>
   1f868:	80 91 c0 00 	lds	r24, 0x00C0
   1f86c:	85 fd       	sbrc	r24, 5
   1f86e:	06 c0       	rjmp	.+12     	; 0x1f87c <uart_putchar+0x1e>
   1f870:	f9 cf       	rjmp	.-14     	; 0x1f864 <uart_putchar+0x6>
   1f872:	80 91 c8 00 	lds	r24, 0x00C8
   1f876:	85 ff       	sbrs	r24, 5
   1f878:	f5 cf       	rjmp	.-22     	; 0x1f864 <uart_putchar+0x6>
    Uart_set_tx_busy();     // Set Busy flag before sending (always)
    Uart_send_byte(ch);
   1f87a:	05 c0       	rjmp	.+10     	; 0x1f886 <uart_putchar+0x28>
   1f87c:	90 93 c6 00 	sts	0x00C6, r25
   1f880:	80 91 c6 00 	lds	r24, 0x00C6
   1f884:	04 c0       	rjmp	.+8      	; 0x1f88e <uart_putchar+0x30>
   1f886:	90 93 ce 00 	sts	0x00CE, r25
   1f88a:	80 91 ce 00 	lds	r24, 0x00CE
    return (ch);
}
   1f88e:	89 2f       	mov	r24, r25
   1f890:	99 27       	eor	r25, r25
   1f892:	08 95       	ret

0001f894 <uart_getchar>:

//------------------------------------------------------------------------------
//  @fn uart_getchar
//!
//! Get a character from the UART peripheral.
//!
//! @warning none
//!
//! @param  none
//!
//! @return read (received) character on the UART
//!
//------------------------------------------------------------------------------
U8 uart_getchar (void)
{
   1f894:	20 91 34 01 	lds	r18, 0x0134
    U8 ch;

    while(!Uart_rx_ready());
   1f898:	22 23       	and	r18, r18
   1f89a:	59 f4       	brne	.+22     	; 0x1f8b2 <uart_getchar+0x1e>
   1f89c:	80 91 c0 00 	lds	r24, 0x00C0
   1f8a0:	99 27       	eor	r25, r25
   1f8a2:	88 0f       	add	r24, r24
   1f8a4:	89 2f       	mov	r24, r25
   1f8a6:	88 1f       	adc	r24, r24
   1f8a8:	99 0b       	sbc	r25, r25
   1f8aa:	91 95       	neg	r25
   1f8ac:	89 2b       	or	r24, r25
   1f8ae:	61 f4       	brne	.+24     	; 0x1f8c8 <uart_getchar+0x34>
   1f8b0:	f3 cf       	rjmp	.-26     	; 0x1f898 <uart_getchar+0x4>
   1f8b2:	80 91 c8 00 	lds	r24, 0x00C8
   1f8b6:	99 27       	eor	r25, r25
   1f8b8:	88 0f       	add	r24, r24
   1f8ba:	89 2f       	mov	r24, r25
   1f8bc:	88 1f       	adc	r24, r24
   1f8be:	99 0b       	sbc	r25, r25
   1f8c0:	91 95       	neg	r25
   1f8c2:	89 2b       	or	r24, r25
   1f8c4:	49 f3       	breq	.-46     	; 0x1f898 <uart_getchar+0x4>
    ch = Uart_get_byte();
   1f8c6:	03 c0       	rjmp	.+6      	; 0x1f8ce <uart_getchar+0x3a>
   1f8c8:	80 91 c6 00 	lds	r24, 0x00C6
   1f8cc:	02 c0       	rjmp	.+4      	; 0x1f8d2 <uart_getchar+0x3e>
   1f8ce:	80 91 ce 00 	lds	r24, 0x00CE
    Uart_ack_rx_byte();
    return ch;
}
   1f8d2:	99 27       	eor	r25, r25
   1f8d4:	08 95       	ret

0001f8d6 <uart_init>:
   1f8d6:	1f 93       	push	r17
   1f8d8:	18 2f       	mov	r17, r24
   1f8da:	80 91 34 01 	lds	r24, 0x0134
   1f8de:	88 23       	and	r24, r24
   1f8e0:	89 f4       	brne	.+34     	; 0x1f904 <uart_init+0x2e>
   1f8e2:	10 92 c1 00 	sts	0x00C1, r1
   1f8e6:	80 91 c6 00 	lds	r24, 0x00C6
   1f8ea:	80 93 c2 00 	sts	0x00C2, r24
   1f8ee:	80 e4       	ldi	r24, 0x40	; 64
   1f8f0:	80 93 c0 00 	sts	0x00C0, r24
   1f8f4:	86 e0       	ldi	r24, 0x06	; 6
   1f8f6:	80 93 c2 00 	sts	0x00C2, r24
   1f8fa:	10 92 c5 00 	sts	0x00C5, r1
   1f8fe:	10 92 c4 00 	sts	0x00C4, r1
   1f902:	10 c0       	rjmp	.+32     	; 0x1f924 <uart_init+0x4e>
   1f904:	10 92 c9 00 	sts	0x00C9, r1
   1f908:	80 91 ce 00 	lds	r24, 0x00CE
   1f90c:	80 93 ca 00 	sts	0x00CA, r24
   1f910:	80 e4       	ldi	r24, 0x40	; 64
   1f912:	80 93 c8 00 	sts	0x00C8, r24
   1f916:	86 e0       	ldi	r24, 0x06	; 6
   1f918:	80 93 ca 00 	sts	0x00CA, r24
   1f91c:	10 92 cd 00 	sts	0x00CD, r1
   1f920:	10 92 cc 00 	sts	0x00CC, r1
   1f924:	60 e0       	ldi	r22, 0x00	; 0
   1f926:	70 e0       	ldi	r23, 0x00	; 0
   1f928:	80 e0       	ldi	r24, 0x00	; 0
   1f92a:	90 e0       	ldi	r25, 0x00	; 0
   1f92c:	0e 94 ac f8 	call	0x1f158	; 0x1f158 <uart_set_baudrate>
   1f930:	88 23       	and	r24, r24
   1f932:	19 f4       	brne	.+6      	; 0x1f93a <uart_init+0x64>
   1f934:	80 e0       	ldi	r24, 0x00	; 0
   1f936:	90 e0       	ldi	r25, 0x00	; 0
   1f938:	53 c0       	rjmp	.+166    	; 0x1f9e0 <uart_init+0x10a>
   1f93a:	80 91 34 01 	lds	r24, 0x0134
   1f93e:	91 2f       	mov	r25, r17
   1f940:	94 70       	andi	r25, 0x04	; 4
   1f942:	41 2f       	mov	r20, r17
   1f944:	48 73       	andi	r20, 0x38	; 56
   1f946:	21 2f       	mov	r18, r17
   1f948:	33 27       	eor	r19, r19
   1f94a:	88 23       	and	r24, r24
   1f94c:	21 f5       	brne	.+72     	; 0x1f996 <uart_init+0xc0>
   1f94e:	80 91 c0 00 	lds	r24, 0x00C0
   1f952:	80 62       	ori	r24, 0x20	; 32
   1f954:	80 93 c0 00 	sts	0x00C0, r24
   1f958:	80 91 c1 00 	lds	r24, 0x00C1
   1f95c:	8b 7f       	andi	r24, 0xFB	; 251
   1f95e:	80 93 c1 00 	sts	0x00C1, r24
   1f962:	80 91 c1 00 	lds	r24, 0x00C1
   1f966:	89 2b       	or	r24, r25
   1f968:	80 93 c1 00 	sts	0x00C1, r24
   1f96c:	40 93 c2 00 	sts	0x00C2, r20
   1f970:	80 91 c2 00 	lds	r24, 0x00C2
   1f974:	23 70       	andi	r18, 0x03	; 3
   1f976:	30 70       	andi	r19, 0x00	; 0
   1f978:	22 0f       	add	r18, r18
   1f97a:	33 1f       	adc	r19, r19
   1f97c:	82 2b       	or	r24, r18
   1f97e:	80 93 c2 00 	sts	0x00C2, r24
   1f982:	80 91 c2 00 	lds	r24, 0x00C2
   1f986:	80 91 c1 00 	lds	r24, 0x00C1
   1f98a:	88 61       	ori	r24, 0x18	; 24
   1f98c:	80 93 c1 00 	sts	0x00C1, r24
   1f990:	80 91 c1 00 	lds	r24, 0x00C1
   1f994:	23 c0       	rjmp	.+70     	; 0x1f9dc <uart_init+0x106>
   1f996:	80 91 c8 00 	lds	r24, 0x00C8
   1f99a:	80 62       	ori	r24, 0x20	; 32
   1f99c:	80 93 c8 00 	sts	0x00C8, r24
   1f9a0:	80 91 c9 00 	lds	r24, 0x00C9
   1f9a4:	8b 7f       	andi	r24, 0xFB	; 251
   1f9a6:	80 93 c9 00 	sts	0x00C9, r24
   1f9aa:	80 91 c9 00 	lds	r24, 0x00C9
   1f9ae:	89 2b       	or	r24, r25
   1f9b0:	80 93 c9 00 	sts	0x00C9, r24
   1f9b4:	40 93 ca 00 	sts	0x00CA, r20
   1f9b8:	80 91 ca 00 	lds	r24, 0x00CA
   1f9bc:	23 70       	andi	r18, 0x03	; 3
   1f9be:	30 70       	andi	r19, 0x00	; 0
   1f9c0:	22 0f       	add	r18, r18
   1f9c2:	33 1f       	adc	r19, r19
   1f9c4:	82 2b       	or	r24, r18
   1f9c6:	80 93 ca 00 	sts	0x00CA, r24
   1f9ca:	80 91 ca 00 	lds	r24, 0x00CA
   1f9ce:	80 91 c9 00 	lds	r24, 0x00C9
   1f9d2:	88 61       	ori	r24, 0x18	; 24
   1f9d4:	80 93 c9 00 	sts	0x00C9, r24
   1f9d8:	80 91 c9 00 	lds	r24, 0x00C9
   1f9dc:	81 e0       	ldi	r24, 0x01	; 1
   1f9de:	90 e0       	ldi	r25, 0x00	; 0
   1f9e0:	1f 91       	pop	r17
   1f9e2:	08 95       	ret

0001f9e4 <isp_jump_to>:
//! @return none
//!
//------------------------------------------------------------------------------
void  isp_jump_to(U16 jump_addr)
{
   1f9e4:	20 e7       	ldi	r18, 0x70	; 112
   1f9e6:	80 30       	cpi	r24, 0x00	; 0
   1f9e8:	92 07       	cpc	r25, r18
   1f9ea:	18 f4       	brcc	.+6      	; 0x1f9f2 <isp_jump_to+0xe>
    if (jump_addr <= (((U16)(FLASHEND - BOOT_LOADER_SIZE))>>1) )
    {
        Indirect_jump_to(jump_addr);   // Start application
   1f9ec:	fc 01       	movw	r30, r24
   1f9ee:	09 94       	ijmp
   1f9f0:	08 95       	ret
    }
    else
    {
        Direct_jump_to_zero();        // Start application at address 0x00000
   1f9f2:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
   1f9f6:	08 95       	ret

0001f9f8 <isp_set_memory>:
    }
}

//------------------------------------------------------------------------------
//  @fn isp_set_memory
//!
//! This function analyzes and set the memory code comming from ISP PROTOCOL.
//!
//! @warning none
//!
//! @param:  mem_code  Memory Code (from 0 to MEM_DEF_MAX)
//!
//! @return none
//!
//------------------------------------------------------------------------------
void  isp_set_memory(U8 mem_code)
{
   1f9f8:	80 93 56 02 	sts	0x0256, r24
   1f9fc:	08 95       	ret

0001f9fe <isp_set_page>:
    isp_select_memory = mem_code;
}

//------------------------------------------------------------------------------
//  @fn isp_set_page
//!
//! This function analyzes and set the page number comming from ISP PROTOCOL.
//!
//! @warning Only Flash Memory Space can have page number != 0
//!
//! @param:  page_nb  Page number
//!
//! @return none
//!
//------------------------------------------------------------------------------
void  isp_set_page(U8 page_nb)
{
   1f9fe:	80 93 59 02 	sts	0x0259, r24
   1fa02:	08 95       	ret

0001fa04 <isp_address_range>:
    isp_select_page = page_nb;
}

//------------------------------------------------------------------------------
//  @fn isp_address_range
//!
//! This function analyzes and set the "isp_start_address" inside 64K range
//! and the "isp_number_of_bytes" comming from ISP PROTOCOL.
//!
//! @warning: 1 - "isp_start_address" inside 64K range
//!           2 - "isp_number_of_bytes": 0x0001=1 byte up to 0xFFFF=65535
//!                bytes
//!
//! @param:  start_addr = start address byte inside 64K range
//!          end_addr   = end address byte inside 64K range
//!
//! @return none
//!
//------------------------------------------------------------------------------
void  isp_address_range(U16 start_addr, U16 end_addr)
{
   1fa04:	90 93 53 02 	sts	0x0253, r25
   1fa08:	80 93 52 02 	sts	0x0252, r24
    isp_start_address = start_addr;
    isp_number_of_bytes = (end_addr - start_addr) + 1;
   1fa0c:	68 1b       	sub	r22, r24
   1fa0e:	79 0b       	sbc	r23, r25
   1fa10:	6f 5f       	subi	r22, 0xFF	; 255
   1fa12:	7f 4f       	sbci	r23, 0xFF	; 255
   1fa14:	70 93 55 02 	sts	0x0255, r23
   1fa18:	60 93 54 02 	sts	0x0254, r22
   1fa1c:	08 95       	ret

0001fa1e <put_conf_block>:
}

//------------------------------------------------------------------------------
//  @fn isp_memory_erase
//!
//! This function performes a full erase (if it is possible) of the memory
//! selected, code number comming from ISP PROTOCOL.
//!
//! @warning: 1 - Some of memories are "READ Only"
//!           2 - Erasing the Flash Memory sets "SSB" (Software Security Byte)
//!               to "SSB_NO_SECURITY"
//!           3 - Boot Loader Configuration is erased with "Default Boot
//!               Loader Configuration" (controled by "SSB").
//!           2 - Each erasing is controled by "SSB".
//!           3 - Boot Loader Configuration erased with "Default Boot Loader
//!
//! @param  none
//!
//! @return: FALSE (0) = Command failed (Security set) or "READ Only" memory targeted
//!          TRUE  (1) = Command available
//!
//------------------------------------------------------------------------------
Bool  isp_memory_erase(void)
{
Bool    rtn = 1;

    switch (isp_select_memory)
    {

    //- FLASH MEMORY ---------------------------------------------------
        case (MEM_FLASH):
            //- KEEP THIS ORDER !
            flash_full_erase();
            put_conf_byte(SSB, SSB_NO_SECURITY);

            break;

    //- EEPROM MEMORY --------------------------------------------------
        case (MEM_EEPROM):
            if((get_conf_byte(SSB)) == SSB_NO_SECURITY)
            {
                eeprom_full_erase();
            }
            else rtn=0;

            break;

    //- BOOT LOADER CONFIGURATION --------------------------------------
        case (MEM_BOOT_CONF):
            if((get_conf_byte(SSB)) == SSB_NO_SECURITY)
            {
                put_conf_block(boot_conf_default, (U16)(boot_conf), BOOT_CONF_SIZE);
            }
            else rtn=0;

            break;

    //- OTHERS ARE "READ ONLY" -----------------------------------------
        default:
            rtn = 0;
            
            break;

    }   // switch (isp_sel...
    return(rtn);
}

//------------------------------------------------------------------------------
//  @fn isp_read_block
//!
//! This function performes a read of "isp_number_of_bytes" of bytes, block
//! by block (size of buffer passed as parameter) on the selected memory
//! ("isp_select_memory") and in the selected page ("isp_select_page") from
//! "isp_start_address".
//!
//! @warning:  This function works on copies of "isp_start_address" and
//!            "isp_number_of_bytes" according with the size of the buffer
//!            passed as parameter. In fact, the calling function is in
//!            charge of manage copies for restoring initial values.
//!
//! @param: - isp_buffer = block for output data
//!         - size = size of isp_buffer
//!
//! @return: 0x00 = "isp_read_block()" block available and transfer
//!                  not finished.
//!          0x01 = "isp_read_block()" last block, then "isp_number_of_bytes"
//!                  is equal to size of this last block.
//!          0xFF = Software Security Byte Set, read not available.
//!
//------------------------------------------------------------------------------
U8  isp_read_block(U8* isp_buffer, U16 size)
{
U16  i;
U8  rtn = 0x00;

    switch (isp_select_memory)
    {

    //- FLASH MEMORY ---------------------------------------------------
        case (MEM_FLASH):
            if( ((get_conf_byte(SSB)) == SSB_NO_SECURITY) || ((get_conf_byte(SSB)) == SSB_WR_PROTECTION) )
            {
#               if defined(_RAMPZ_IS_USED_)
                    RAMPZ = isp_select_page;
#               endif   //- If _RAMPZ_IS_USED_ ...

                if (size !=0)   //- Not 64K
                {
                    size = Min (size, isp_number_of_bytes); //- Macro in "compiler.h"
                }
                for (i=0; i< size; i++)
                {
                    isp_buffer[i] = flash_rd_byte(isp_start_address);
                    isp_start_address++;
                    isp_number_of_bytes--;
                }
                if (isp_number_of_bytes == 0)
                {
                    isp_number_of_bytes = size;
                    rtn = 0x01;
                }
            }
            else rtn = 0xFF;
            
            break;

    //- EEPROM MEMORY --------------------------------------------------
        case (MEM_EEPROM):
            if( ((get_conf_byte(SSB)) == SSB_NO_SECURITY) || ((get_conf_byte(SSB)) == SSB_WR_PROTECTION) )
            {
                size = Min (size, isp_number_of_bytes); //- Macro in "compiler.h"
                for (i=0; i< size; i++)
                {
                    isp_buffer[i] = eeprom_rd_byte(isp_start_address);
                    isp_start_address++;
                    isp_number_of_bytes--;
                }
                if (isp_number_of_bytes == 0)
                {
                    isp_number_of_bytes = size;
                    rtn = 0x01;
                }
            }
            else rtn = 0xFF;
            
            break;

    //- DEVICE SIGNATURE -----------------------------------------------
        case (MEM_SIGNATURE):   //-  (MAX 4 Bytes)
            size = Min (size, isp_number_of_bytes); //- Macro in "compiler.h"
            for (i=0; i< size; i++)
            {
                if      ( isp_start_address == 0 ) isp_buffer[i] = MANUF_ID;
                else if ( isp_start_address == 1 ) isp_buffer[i] = FAMILY_CODE;
                else if ( isp_start_address == 2 ) isp_buffer[i] = PRODUCT_NAME;
                else                               isp_buffer[i] = PRODUCT_REV;

                isp_start_address++;
                isp_number_of_bytes--;
            }
            if (isp_number_of_bytes == 0)
            {
                isp_number_of_bytes = size;
                rtn = 0x01;
            }
            
            break;

    //- BOOT LOADER INFORMATION ----------------------------------------
        case (MEM_BOOT_INF):    //-  (MAX 3 Bytes)
            size = Min (size, isp_number_of_bytes); //- Macro in "compiler.h"
            for (i=0; i< size; i++)
            {
                if      ( isp_start_address == 0 ) isp_buffer[i] = BOOT_VERSION;
                else if ( isp_start_address == 1 ) isp_buffer[i] = BOOT_ID1;
                else                               isp_buffer[i] = BOOT_ID2;

                isp_start_address++;
                isp_number_of_bytes--;
            }
            if (isp_number_of_bytes == 0)
            {
                isp_number_of_bytes = size;
                rtn = 0x01;
            }

            break;

    //- BOOT LOADER CONFIGURATION --------------------------------------
        case (MEM_BOOT_CONF):
            size = Min (size, isp_number_of_bytes); //- Macro in "compiler.h"
            for (i=0; i< size; i++)
            {
                isp_buffer[i] = get_conf_byte((U16) (&(boot_conf[isp_start_address])));
                isp_start_address++;
                isp_number_of_bytes--;
            }
            if (isp_number_of_bytes == 0)
            {
                isp_number_of_bytes = size;
                rtn = 0x01;
            }

            break;

    //- DEVICE REGISTERS -----------------------------------------------
        case (MEM_HW_REG):
            size = Min (size, isp_number_of_bytes); //- Macro in "compiler.h"
            for (i=0; i< size; i++)
            {
                isp_buffer[i] = REGISTER_BYTE_AT(isp_start_address);
                isp_start_address++;
                isp_number_of_bytes--;
            }
            if (isp_number_of_bytes == 0)
            {
                isp_number_of_bytes = size;
                rtn = 0x01;
            }
            
            break;

    //- NO MORE TYPE OF MEMORY -----------------------------------------
        default:
            rtn = 0xFF;
            
            break;

    }   // switch (isp_sel...
    return(rtn);
}

//------------------------------------------------------------------------------
//  @fn isp_blank_check
//!
//! This function performes a blank check of "isp_number_of_bytes" of bytes
//! on the selected memory ("isp_select_memory") and in the selected page
//! ("isp_select_page") from "isp_start_address".
//!
//! @warning  none
//!
//! @param  none
//!
//! @return: TRUE  (1) = no error, memory range blank.
//!          FALSE (0) = "isp_blank_check()" error, then "isp_start_address"
//!                       is equal to the address of the first byte not blank.
//!
//------------------------------------------------------------------------------
Bool  isp_blank_check(void)
{
Bool    rtn = TRUE;

    switch (isp_select_memory)
    {

    //- FLASH MEMORY ---------------------------------------------------
        case (MEM_FLASH):
#           if defined(_RAMPZ_IS_USED_)
                RAMPZ = isp_select_page;
#           endif   //- If _RAMPZ_IS_USED_ ...
            while(1)
            {
                if ( (flash_rd_byte(isp_start_address)) != ((U8)(FLASH_BLANK_WORD)) )
                {
                    rtn = FALSE; break;  //- NOT BLANK exit from:  while(...
                }
                isp_start_address++;
                isp_number_of_bytes--;
                if(isp_number_of_bytes==0) break;  //- Std exit from: while(....
            }
            
            break;

    //- EEPROM MEMORY --------------------------------------------------
        case (MEM_EEPROM):
            while(1)
            {
                if ( (eeprom_rd_byte(isp_start_address)) != EEPROM_BLANK_BYTE )
                {
                    rtn = FALSE; break;  //- NOT BLANK exit from:  while(...
                }
                isp_start_address++;
                isp_number_of_bytes--;
                if(isp_number_of_bytes==0) break;  //- Std exit from: while(....
            }
            
            break;

    //- BOOT LOADER CONFIGURATION --------------------------------------
        case (MEM_BOOT_CONF):
            while(1)
            {
                if ( (get_conf_byte((U16) (&(boot_conf[isp_start_address]))))  \
                   != (boot_conf_default[isp_start_address]) )
                {
                    rtn = FALSE; break;  //- NOT BLANK exit from:  while(...
                }
                isp_start_address++;
                isp_number_of_bytes--;
                if(isp_number_of_bytes==0) break;  //- Std exit from: while(....
            }

            break;

    //- OTHERS ARE EQUAL TO THEIR DEFINITION ---------------------------
        default:
            
            break;

    }   // switch (isp_sel...
    return(rtn);
}

//----------------------------------------------------------------------
//  @fn isp_prog_block
//!
//! This function performes a programmation of "isp_number_of_bytes" of bytes,
//! block by block (size of buffer passed as parameter) on the selected
//! memory ("isp_select_memory") and in the selected page ("isp_select_page")
//! from "isp_start_address".
//!
//! @warning:  This function works with "isp_start_address" and
//!            "isp_number_of_bytes" according with the size of the buffer
//!            passed as parameter. In fact, the calling function is in
//!            charge of manage copies for restoring initial values.
//!
//! @param: - isp_buffer = block for input data
//!         - size = size of isp_buffer
//!
//! @return: 0x00 = "isp_prog_block()" block programming completed and transfer
//!                  not finished.
//!          0x01 = "isp_prog_block()" last block, then "isp_number_of_bytes"
//!                  is equal to size of this last block.
//!          0xFF = Software Security Byte Set, write not available.
//!
//------------------------------------------------------------------------------
U8  isp_prog_block(U8* isp_buffer, U16 size)
{
U8  rtn = 0x00;

    switch (isp_select_memory)
    {

    //- FLASH MEMORY ---------------------------------------------------
        case (MEM_FLASH):
            if( (get_conf_byte(SSB)) == SSB_NO_SECURITY )
            {
#               if defined(_RAMPZ_IS_USED_) //- CARE: Hereunder SSB test can destroy RAMPZ
                    RAMPZ = isp_select_page;
#               endif   //- If _RAMPZ_IS_USED_ ...

                //- It is not neccessary to check size (as for read) because
                //- the host send exactly what it is needed
                flash_wr_block(isp_buffer, isp_start_address, size);

                isp_start_address += size;
                isp_number_of_bytes -= size;

                if (isp_number_of_bytes == 0) rtn = 0x01;
            }
            else rtn = 0xFF;
            
            break;

    //- EEPROM MEMORY --------------------------------------------------
        case (MEM_EEPROM):
            if( (get_conf_byte(SSB)) == SSB_NO_SECURITY )
            {
                //- It is not neccessary to check size (as for read) because
                //- the host send exactly what it is needed

                eeprom_wr_block(isp_buffer, isp_start_address, size);

                isp_start_address += size;
                isp_number_of_bytes -= size;

                if (isp_number_of_bytes == 0) rtn = 0x01;
            }
            else rtn = 0xFF;
            
            break;

    //- BOOT LOADER CONFIGURATION --------------------------------------
        case (MEM_BOOT_CONF):

            //- It is not neccessary to check size (as for read) because
            //- the host send exactly what it is needed

            if( (get_conf_byte(SSB)) == SSB_NO_SECURITY )
            {
                put_conf_block(isp_buffer, ( isp_start_address + ((U16)(boot_conf)) ), size);

                isp_start_address += size;
                isp_number_of_bytes -= size;

                if (isp_number_of_bytes == 0) rtn = 0x01;
            }
            else if ( ((get_conf_byte(SSB)) == SSB_WR_PROTECTION) && \
                      (isp_start_address == SSB_INDEX) && \
                      (size == 1) && (isp_buffer[0] == SSB_RD_WR_PROTECTION ) )
            {
                put_conf_byte(SSB, SSB_RD_WR_PROTECTION);
                rtn = 0x01;
            }
            else rtn = 0xFF;

            break;

    //- NO MORE TYPE OF MEMORY IN WRITE ACCESS -------------------------
        default:
            rtn = 0xFF;
            
            break;

    }   // switch (isp_sel...
    return(rtn);
}

//------------------------------------------------------------------------------
//  @fn get_conf_byte
//!
//! This function gets a Bootloader Configuration Byte.
//!
//! @warning  none
//!
//! @param:  "Configuration_Byte" address
//!
//! @return: "Configuration_Byte" value.
//!
//------------------------------------------------------------------------------
U8  get_conf_byte(U16 conf_byte)
{
U8 rtn;

#if defined(_RAMPZ_IS_USED_)
U8 rampz_copy;

    rampz_copy = RAMPZ; 
    RAMPZ = 1; 
    rtn = flash_rd_byte(conf_byte);
    RAMPZ = rampz_copy;
#else
    rtn = flash_rd_byte(conf_byte);
#endif
    return(rtn);
}

//------------------------------------------------------------------------------
//  @fn put_conf_byte
//!
//! This function writes a Bootloader Configuration Byte.
//!
//! @warning  none
//!
//! @param:  - "Configuration_Byte" address
//!          - "Configuration_Byte" value
//!
//! @return  none
//!
//------------------------------------------------------------------------------
void  put_conf_byte(U16 conf_byte, U8 value)
{

#if defined(_RAMPZ_IS_USED_)
U8 rampz_copy;

    rampz_copy = RAMPZ; 
    RAMPZ = 1; 
    flash_wr_byte(conf_byte, value);
    RAMPZ = rampz_copy;
#else
    flash_wr_byte(conf_byte, value);
#endif
}

//------------------------------------------------------------------------------
//  @fn put_conf_block
//!
//! This function writes a Bootloader Configuration Block.
//!
//! @warning  none
//!
//! @param: - src      Source of (SRAM) buffer Address.
//!         - dest     "Configuration_Byte" first address.
//!         - byte_nb  Number of "Configuration_Bytes" to write.
//!
//! @return none
//!
//------------------------------------------------------------------------------
void  put_conf_block(U8* src, U16 dest, U16 byte_nb)
{
   1fa1e:	1f 93       	push	r17

#if defined(_RAMPZ_IS_USED_)
U8 rampz_copy;

    rampz_copy = RAMPZ; 
   1fa20:	1b b7       	in	r17, 0x3b	; 59
    RAMPZ = 1; 
   1fa22:	21 e0       	ldi	r18, 0x01	; 1
   1fa24:	2b bf       	out	0x3b, r18	; 59
    flash_wr_block(src, dest, byte_nb);
   1fa26:	0e 94 b5 f1 	call	0x1e36a	; 0x1e36a <flash_wr_block>
    RAMPZ = rampz_copy;
   1fa2a:	1b bf       	out	0x3b, r17	; 59
   1fa2c:	1f 91       	pop	r17
   1fa2e:	08 95       	ret

0001fa30 <put_conf_byte>:
   1fa30:	1f 93       	push	r17
   1fa32:	1b b7       	in	r17, 0x3b	; 59
   1fa34:	21 e0       	ldi	r18, 0x01	; 1
   1fa36:	2b bf       	out	0x3b, r18	; 59
   1fa38:	0e 94 76 f2 	call	0x1e4ec	; 0x1e4ec <flash_wr_byte>
   1fa3c:	1b bf       	out	0x3b, r17	; 59
   1fa3e:	1f 91       	pop	r17
   1fa40:	08 95       	ret

0001fa42 <get_conf_byte>:
   1fa42:	1f 93       	push	r17
   1fa44:	1b b7       	in	r17, 0x3b	; 59
   1fa46:	21 e0       	ldi	r18, 0x01	; 1
   1fa48:	2b bf       	out	0x3b, r18	; 59
   1fa4a:	0e 94 2c f1 	call	0x1e258	; 0x1e258 <flash_rd_byte>
   1fa4e:	1b bf       	out	0x3b, r17	; 59
   1fa50:	99 27       	eor	r25, r25
   1fa52:	1f 91       	pop	r17
   1fa54:	08 95       	ret

0001fa56 <isp_prog_block>:
   1fa56:	0f 93       	push	r16
   1fa58:	1f 93       	push	r17
   1fa5a:	cf 93       	push	r28
   1fa5c:	df 93       	push	r29
   1fa5e:	8c 01       	movw	r16, r24
   1fa60:	eb 01       	movw	r28, r22
   1fa62:	80 91 56 02 	lds	r24, 0x0256
   1fa66:	81 30       	cpi	r24, 0x01	; 1
   1fa68:	c9 f0       	breq	.+50     	; 0x1fa9c <isp_prog_block+0x46>
   1fa6a:	81 30       	cpi	r24, 0x01	; 1
   1fa6c:	20 f0       	brcs	.+8      	; 0x1fa76 <isp_prog_block+0x20>
   1fa6e:	84 30       	cpi	r24, 0x04	; 4
   1fa70:	09 f0       	breq	.+2      	; 0x1fa74 <isp_prog_block+0x1e>
   1fa72:	65 c0       	rjmp	.+202    	; 0x1fb3e <isp_prog_block+0xe8>
   1fa74:	3a c0       	rjmp	.+116    	; 0x1faea <isp_prog_block+0x94>
   1fa76:	81 ef       	ldi	r24, 0xF1	; 241
   1fa78:	9f ef       	ldi	r25, 0xFF	; 255
   1fa7a:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fa7e:	8f 3f       	cpi	r24, 0xFF	; 255
   1fa80:	09 f0       	breq	.+2      	; 0x1fa84 <isp_prog_block+0x2e>
   1fa82:	5d c0       	rjmp	.+186    	; 0x1fb3e <isp_prog_block+0xe8>
   1fa84:	80 91 59 02 	lds	r24, 0x0259
   1fa88:	8b bf       	out	0x3b, r24	; 59
   1fa8a:	60 91 52 02 	lds	r22, 0x0252
   1fa8e:	70 91 53 02 	lds	r23, 0x0253
   1fa92:	ae 01       	movw	r20, r28
   1fa94:	c8 01       	movw	r24, r16
   1fa96:	0e 94 b5 f1 	call	0x1e36a	; 0x1e36a <flash_wr_block>
   1fa9a:	0f c0       	rjmp	.+30     	; 0x1faba <isp_prog_block+0x64>
   1fa9c:	81 ef       	ldi	r24, 0xF1	; 241
   1fa9e:	9f ef       	ldi	r25, 0xFF	; 255
   1faa0:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1faa4:	8f 3f       	cpi	r24, 0xFF	; 255
   1faa6:	09 f0       	breq	.+2      	; 0x1faaa <isp_prog_block+0x54>
   1faa8:	4a c0       	rjmp	.+148    	; 0x1fb3e <isp_prog_block+0xe8>
   1faaa:	60 91 52 02 	lds	r22, 0x0252
   1faae:	70 91 53 02 	lds	r23, 0x0253
   1fab2:	ae 01       	movw	r20, r28
   1fab4:	c8 01       	movw	r24, r16
   1fab6:	0e 94 36 f8 	call	0x1f06c	; 0x1f06c <eeprom_wr_block>
   1faba:	80 91 52 02 	lds	r24, 0x0252
   1fabe:	90 91 53 02 	lds	r25, 0x0253
   1fac2:	8c 0f       	add	r24, r28
   1fac4:	9d 1f       	adc	r25, r29
   1fac6:	90 93 53 02 	sts	0x0253, r25
   1faca:	80 93 52 02 	sts	0x0252, r24
   1face:	80 91 54 02 	lds	r24, 0x0254
   1fad2:	90 91 55 02 	lds	r25, 0x0255
   1fad6:	8c 1b       	sub	r24, r28
   1fad8:	9d 0b       	sbc	r25, r29
   1fada:	90 93 55 02 	sts	0x0255, r25
   1fade:	80 93 54 02 	sts	0x0254, r24
   1fae2:	20 e0       	ldi	r18, 0x00	; 0
   1fae4:	89 2b       	or	r24, r25
   1fae6:	61 f5       	brne	.+88     	; 0x1fb40 <isp_prog_block+0xea>
   1fae8:	28 c0       	rjmp	.+80     	; 0x1fb3a <isp_prog_block+0xe4>
   1faea:	81 ef       	ldi	r24, 0xF1	; 241
   1faec:	9f ef       	ldi	r25, 0xFF	; 255
   1faee:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1faf2:	8f 3f       	cpi	r24, 0xFF	; 255
   1faf4:	59 f4       	brne	.+22     	; 0x1fb0c <isp_prog_block+0xb6>
   1faf6:	60 91 52 02 	lds	r22, 0x0252
   1fafa:	70 91 53 02 	lds	r23, 0x0253
   1fafe:	60 51       	subi	r22, 0x10	; 16
   1fb00:	70 40       	sbci	r23, 0x00	; 0
   1fb02:	ae 01       	movw	r20, r28
   1fb04:	c8 01       	movw	r24, r16
   1fb06:	0e 94 0f fd 	call	0x1fa1e	; 0x1fa1e <put_conf_block>
   1fb0a:	d7 cf       	rjmp	.-82     	; 0x1faba <isp_prog_block+0x64>
   1fb0c:	81 ef       	ldi	r24, 0xF1	; 241
   1fb0e:	9f ef       	ldi	r25, 0xFF	; 255
   1fb10:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fb14:	8e 3f       	cpi	r24, 0xFE	; 254
   1fb16:	99 f4       	brne	.+38     	; 0x1fb3e <isp_prog_block+0xe8>
   1fb18:	80 91 52 02 	lds	r24, 0x0252
   1fb1c:	90 91 53 02 	lds	r25, 0x0253
   1fb20:	01 97       	sbiw	r24, 0x01	; 1
   1fb22:	69 f4       	brne	.+26     	; 0x1fb3e <isp_prog_block+0xe8>
   1fb24:	21 97       	sbiw	r28, 0x01	; 1
   1fb26:	59 f4       	brne	.+22     	; 0x1fb3e <isp_prog_block+0xe8>
   1fb28:	f8 01       	movw	r30, r16
   1fb2a:	80 81       	ld	r24, Z
   1fb2c:	8c 3f       	cpi	r24, 0xFC	; 252
   1fb2e:	39 f4       	brne	.+14     	; 0x1fb3e <isp_prog_block+0xe8>
   1fb30:	6c ef       	ldi	r22, 0xFC	; 252
   1fb32:	81 ef       	ldi	r24, 0xF1	; 241
   1fb34:	9f ef       	ldi	r25, 0xFF	; 255
   1fb36:	0e 94 18 fd 	call	0x1fa30	; 0x1fa30 <put_conf_byte>
   1fb3a:	21 e0       	ldi	r18, 0x01	; 1
   1fb3c:	01 c0       	rjmp	.+2      	; 0x1fb40 <isp_prog_block+0xea>
   1fb3e:	2f ef       	ldi	r18, 0xFF	; 255
   1fb40:	82 2f       	mov	r24, r18
   1fb42:	99 27       	eor	r25, r25
   1fb44:	df 91       	pop	r29
   1fb46:	cf 91       	pop	r28
   1fb48:	1f 91       	pop	r17
   1fb4a:	0f 91       	pop	r16
   1fb4c:	08 95       	ret

0001fb4e <isp_blank_check>:
   1fb4e:	80 91 56 02 	lds	r24, 0x0256
   1fb52:	81 30       	cpi	r24, 0x01	; 1
   1fb54:	41 f1       	breq	.+80     	; 0x1fba6 <isp_blank_check+0x58>
   1fb56:	81 30       	cpi	r24, 0x01	; 1
   1fb58:	20 f0       	brcs	.+8      	; 0x1fb62 <isp_blank_check+0x14>
   1fb5a:	84 30       	cpi	r24, 0x04	; 4
   1fb5c:	09 f0       	breq	.+2      	; 0x1fb60 <isp_blank_check+0x12>
   1fb5e:	63 c0       	rjmp	.+198    	; 0x1fc26 <isp_blank_check+0xd8>
   1fb60:	3f c0       	rjmp	.+126    	; 0x1fbe0 <isp_blank_check+0x92>
   1fb62:	80 91 59 02 	lds	r24, 0x0259
   1fb66:	8b bf       	out	0x3b, r24	; 59
   1fb68:	80 91 52 02 	lds	r24, 0x0252
   1fb6c:	90 91 53 02 	lds	r25, 0x0253
   1fb70:	0e 94 2c f1 	call	0x1e258	; 0x1e258 <flash_rd_byte>
   1fb74:	8f 3f       	cpi	r24, 0xFF	; 255
   1fb76:	09 f0       	breq	.+2      	; 0x1fb7a <isp_blank_check+0x2c>
   1fb78:	58 c0       	rjmp	.+176    	; 0x1fc2a <isp_blank_check+0xdc>
   1fb7a:	80 91 52 02 	lds	r24, 0x0252
   1fb7e:	90 91 53 02 	lds	r25, 0x0253
   1fb82:	01 96       	adiw	r24, 0x01	; 1
   1fb84:	90 93 53 02 	sts	0x0253, r25
   1fb88:	80 93 52 02 	sts	0x0252, r24
   1fb8c:	80 91 54 02 	lds	r24, 0x0254
   1fb90:	90 91 55 02 	lds	r25, 0x0255
   1fb94:	01 97       	sbiw	r24, 0x01	; 1
   1fb96:	90 93 55 02 	sts	0x0255, r25
   1fb9a:	80 93 54 02 	sts	0x0254, r24
   1fb9e:	89 2b       	or	r24, r25
   1fba0:	09 f4       	brne	.+2      	; 0x1fba4 <isp_blank_check+0x56>
   1fba2:	41 c0       	rjmp	.+130    	; 0x1fc26 <isp_blank_check+0xd8>
   1fba4:	e1 cf       	rjmp	.-62     	; 0x1fb68 <isp_blank_check+0x1a>
   1fba6:	80 91 52 02 	lds	r24, 0x0252
   1fbaa:	90 91 53 02 	lds	r25, 0x0253
   1fbae:	0e 94 24 f8 	call	0x1f048	; 0x1f048 <eeprom_rd_byte>
   1fbb2:	8f 3f       	cpi	r24, 0xFF	; 255
   1fbb4:	d1 f5       	brne	.+116    	; 0x1fc2a <isp_blank_check+0xdc>
   1fbb6:	80 91 52 02 	lds	r24, 0x0252
   1fbba:	90 91 53 02 	lds	r25, 0x0253
   1fbbe:	01 96       	adiw	r24, 0x01	; 1
   1fbc0:	90 93 53 02 	sts	0x0253, r25
   1fbc4:	80 93 52 02 	sts	0x0252, r24
   1fbc8:	80 91 54 02 	lds	r24, 0x0254
   1fbcc:	90 91 55 02 	lds	r25, 0x0255
   1fbd0:	01 97       	sbiw	r24, 0x01	; 1
   1fbd2:	90 93 55 02 	sts	0x0255, r25
   1fbd6:	80 93 54 02 	sts	0x0254, r24
   1fbda:	89 2b       	or	r24, r25
   1fbdc:	21 f1       	breq	.+72     	; 0x1fc26 <isp_blank_check+0xd8>
   1fbde:	e3 cf       	rjmp	.-58     	; 0x1fba6 <isp_blank_check+0x58>
   1fbe0:	80 91 52 02 	lds	r24, 0x0252
   1fbe4:	90 91 53 02 	lds	r25, 0x0253
   1fbe8:	80 51       	subi	r24, 0x10	; 16
   1fbea:	90 40       	sbci	r25, 0x00	; 0
   1fbec:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fbf0:	20 91 52 02 	lds	r18, 0x0252
   1fbf4:	30 91 53 02 	lds	r19, 0x0253
   1fbf8:	f9 01       	movw	r30, r18
   1fbfa:	e0 50       	subi	r30, 0x00	; 0
   1fbfc:	ff 4f       	sbci	r31, 0xFF	; 255
   1fbfe:	90 81       	ld	r25, Z
   1fc00:	89 17       	cp	r24, r25
   1fc02:	99 f4       	brne	.+38     	; 0x1fc2a <isp_blank_check+0xdc>
   1fc04:	2f 5f       	subi	r18, 0xFF	; 255
   1fc06:	3f 4f       	sbci	r19, 0xFF	; 255
   1fc08:	30 93 53 02 	sts	0x0253, r19
   1fc0c:	20 93 52 02 	sts	0x0252, r18
   1fc10:	80 91 54 02 	lds	r24, 0x0254
   1fc14:	90 91 55 02 	lds	r25, 0x0255
   1fc18:	01 97       	sbiw	r24, 0x01	; 1
   1fc1a:	90 93 55 02 	sts	0x0255, r25
   1fc1e:	80 93 54 02 	sts	0x0254, r24
   1fc22:	89 2b       	or	r24, r25
   1fc24:	e9 f6       	brne	.-70     	; 0x1fbe0 <isp_blank_check+0x92>
   1fc26:	81 e0       	ldi	r24, 0x01	; 1
   1fc28:	01 c0       	rjmp	.+2      	; 0x1fc2c <isp_blank_check+0xde>
   1fc2a:	80 e0       	ldi	r24, 0x00	; 0
   1fc2c:	99 27       	eor	r25, r25
   1fc2e:	08 95       	ret

0001fc30 <isp_read_block>:
   1fc30:	ef 92       	push	r14
   1fc32:	ff 92       	push	r15
   1fc34:	0f 93       	push	r16
   1fc36:	1f 93       	push	r17
   1fc38:	cf 93       	push	r28
   1fc3a:	df 93       	push	r29
   1fc3c:	7c 01       	movw	r14, r24
   1fc3e:	eb 01       	movw	r28, r22
   1fc40:	80 91 56 02 	lds	r24, 0x0256
   1fc44:	82 30       	cpi	r24, 0x02	; 2
   1fc46:	09 f4       	brne	.+2      	; 0x1fc4a <isp_read_block+0x1a>
   1fc48:	9f c0       	rjmp	.+318    	; 0x1fd88 <isp_read_block+0x158>
   1fc4a:	83 30       	cpi	r24, 0x03	; 3
   1fc4c:	30 f4       	brcc	.+12     	; 0x1fc5a <isp_read_block+0x2a>
   1fc4e:	88 23       	and	r24, r24
   1fc50:	71 f0       	breq	.+28     	; 0x1fc6e <isp_read_block+0x3e>
   1fc52:	81 30       	cpi	r24, 0x01	; 1
   1fc54:	09 f0       	breq	.+2      	; 0x1fc58 <isp_read_block+0x28>
   1fc56:	68 c1       	rjmp	.+720    	; 0x1ff28 <isp_read_block+0x2f8>
   1fc58:	53 c0       	rjmp	.+166    	; 0x1fd00 <isp_read_block+0xd0>
   1fc5a:	84 30       	cpi	r24, 0x04	; 4
   1fc5c:	09 f4       	brne	.+2      	; 0x1fc60 <isp_read_block+0x30>
   1fc5e:	03 c1       	rjmp	.+518    	; 0x1fe66 <isp_read_block+0x236>
   1fc60:	84 30       	cpi	r24, 0x04	; 4
   1fc62:	08 f4       	brcc	.+2      	; 0x1fc66 <isp_read_block+0x36>
   1fc64:	cb c0       	rjmp	.+406    	; 0x1fdfc <isp_read_block+0x1cc>
   1fc66:	85 30       	cpi	r24, 0x05	; 5
   1fc68:	09 f0       	breq	.+2      	; 0x1fc6c <isp_read_block+0x3c>
   1fc6a:	5e c1       	rjmp	.+700    	; 0x1ff28 <isp_read_block+0x2f8>
   1fc6c:	29 c1       	rjmp	.+594    	; 0x1fec0 <isp_read_block+0x290>
   1fc6e:	81 ef       	ldi	r24, 0xF1	; 241
   1fc70:	9f ef       	ldi	r25, 0xFF	; 255
   1fc72:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fc76:	8f 3f       	cpi	r24, 0xFF	; 255
   1fc78:	39 f0       	breq	.+14     	; 0x1fc88 <isp_read_block+0x58>
   1fc7a:	81 ef       	ldi	r24, 0xF1	; 241
   1fc7c:	9f ef       	ldi	r25, 0xFF	; 255
   1fc7e:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fc82:	8e 3f       	cpi	r24, 0xFE	; 254
   1fc84:	09 f0       	breq	.+2      	; 0x1fc88 <isp_read_block+0x58>
   1fc86:	50 c1       	rjmp	.+672    	; 0x1ff28 <isp_read_block+0x2f8>
   1fc88:	80 91 59 02 	lds	r24, 0x0259
   1fc8c:	8b bf       	out	0x3b, r24	; 59
   1fc8e:	20 97       	sbiw	r28, 0x00	; 0
   1fc90:	41 f0       	breq	.+16     	; 0x1fca2 <isp_read_block+0x72>
   1fc92:	80 91 54 02 	lds	r24, 0x0254
   1fc96:	90 91 55 02 	lds	r25, 0x0255
   1fc9a:	8c 17       	cp	r24, r28
   1fc9c:	9d 07       	cpc	r25, r29
   1fc9e:	08 f4       	brcc	.+2      	; 0x1fca2 <isp_read_block+0x72>
   1fca0:	ec 01       	movw	r28, r24
   1fca2:	00 e0       	ldi	r16, 0x00	; 0
   1fca4:	10 e0       	ldi	r17, 0x00	; 0
   1fca6:	1d c0       	rjmp	.+58     	; 0x1fce2 <isp_read_block+0xb2>
   1fca8:	80 91 52 02 	lds	r24, 0x0252
   1fcac:	90 91 53 02 	lds	r25, 0x0253
   1fcb0:	0e 94 2c f1 	call	0x1e258	; 0x1e258 <flash_rd_byte>
   1fcb4:	f7 01       	movw	r30, r14
   1fcb6:	81 93       	st	Z+, r24
   1fcb8:	7f 01       	movw	r14, r30
   1fcba:	80 91 52 02 	lds	r24, 0x0252
   1fcbe:	90 91 53 02 	lds	r25, 0x0253
   1fcc2:	01 96       	adiw	r24, 0x01	; 1
   1fcc4:	90 93 53 02 	sts	0x0253, r25
   1fcc8:	80 93 52 02 	sts	0x0252, r24
   1fccc:	80 91 54 02 	lds	r24, 0x0254
   1fcd0:	90 91 55 02 	lds	r25, 0x0255
   1fcd4:	01 97       	sbiw	r24, 0x01	; 1
   1fcd6:	90 93 55 02 	sts	0x0255, r25
   1fcda:	80 93 54 02 	sts	0x0254, r24
   1fcde:	0f 5f       	subi	r16, 0xFF	; 255
   1fce0:	1f 4f       	sbci	r17, 0xFF	; 255
   1fce2:	0c 17       	cp	r16, r28
   1fce4:	1d 07       	cpc	r17, r29
   1fce6:	01 f7       	brne	.-64     	; 0x1fca8 <isp_read_block+0x78>
   1fce8:	80 91 54 02 	lds	r24, 0x0254
   1fcec:	90 91 55 02 	lds	r25, 0x0255
   1fcf0:	89 2b       	or	r24, r25
   1fcf2:	09 f0       	breq	.+2      	; 0x1fcf6 <isp_read_block+0xc6>
   1fcf4:	1b c1       	rjmp	.+566    	; 0x1ff2c <isp_read_block+0x2fc>
   1fcf6:	d0 93 55 02 	sts	0x0255, r29
   1fcfa:	c0 93 54 02 	sts	0x0254, r28
   1fcfe:	42 c0       	rjmp	.+132    	; 0x1fd84 <isp_read_block+0x154>
   1fd00:	81 ef       	ldi	r24, 0xF1	; 241
   1fd02:	9f ef       	ldi	r25, 0xFF	; 255
   1fd04:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fd08:	8f 3f       	cpi	r24, 0xFF	; 255
   1fd0a:	39 f0       	breq	.+14     	; 0x1fd1a <isp_read_block+0xea>
   1fd0c:	81 ef       	ldi	r24, 0xF1	; 241
   1fd0e:	9f ef       	ldi	r25, 0xFF	; 255
   1fd10:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fd14:	8e 3f       	cpi	r24, 0xFE	; 254
   1fd16:	09 f0       	breq	.+2      	; 0x1fd1a <isp_read_block+0xea>
   1fd18:	07 c1       	rjmp	.+526    	; 0x1ff28 <isp_read_block+0x2f8>
   1fd1a:	00 91 54 02 	lds	r16, 0x0254
   1fd1e:	10 91 55 02 	lds	r17, 0x0255
   1fd22:	c0 17       	cp	r28, r16
   1fd24:	d1 07       	cpc	r29, r17
   1fd26:	08 f4       	brcc	.+2      	; 0x1fd2a <isp_read_block+0xfa>
   1fd28:	8e 01       	movw	r16, r28
   1fd2a:	c0 e0       	ldi	r28, 0x00	; 0
   1fd2c:	d0 e0       	ldi	r29, 0x00	; 0
   1fd2e:	1c c0       	rjmp	.+56     	; 0x1fd68 <isp_read_block+0x138>
   1fd30:	80 91 52 02 	lds	r24, 0x0252
   1fd34:	90 91 53 02 	lds	r25, 0x0253
   1fd38:	0e 94 24 f8 	call	0x1f048	; 0x1f048 <eeprom_rd_byte>
   1fd3c:	f7 01       	movw	r30, r14
   1fd3e:	81 93       	st	Z+, r24
   1fd40:	7f 01       	movw	r14, r30
   1fd42:	80 91 52 02 	lds	r24, 0x0252
   1fd46:	90 91 53 02 	lds	r25, 0x0253
   1fd4a:	01 96       	adiw	r24, 0x01	; 1
   1fd4c:	90 93 53 02 	sts	0x0253, r25
   1fd50:	80 93 52 02 	sts	0x0252, r24
   1fd54:	80 91 54 02 	lds	r24, 0x0254
   1fd58:	90 91 55 02 	lds	r25, 0x0255
   1fd5c:	01 97       	sbiw	r24, 0x01	; 1
   1fd5e:	90 93 55 02 	sts	0x0255, r25
   1fd62:	80 93 54 02 	sts	0x0254, r24
   1fd66:	21 96       	adiw	r28, 0x01	; 1
   1fd68:	c0 17       	cp	r28, r16
   1fd6a:	d1 07       	cpc	r29, r17
   1fd6c:	09 f7       	brne	.-62     	; 0x1fd30 <isp_read_block+0x100>
   1fd6e:	80 91 54 02 	lds	r24, 0x0254
   1fd72:	90 91 55 02 	lds	r25, 0x0255
   1fd76:	89 2b       	or	r24, r25
   1fd78:	09 f0       	breq	.+2      	; 0x1fd7c <isp_read_block+0x14c>
   1fd7a:	d8 c0       	rjmp	.+432    	; 0x1ff2c <isp_read_block+0x2fc>
   1fd7c:	10 93 55 02 	sts	0x0255, r17
   1fd80:	00 93 54 02 	sts	0x0254, r16
   1fd84:	81 e0       	ldi	r24, 0x01	; 1
   1fd86:	d3 c0       	rjmp	.+422    	; 0x1ff2e <isp_read_block+0x2fe>
   1fd88:	20 91 54 02 	lds	r18, 0x0254
   1fd8c:	30 91 55 02 	lds	r19, 0x0255
   1fd90:	62 17       	cp	r22, r18
   1fd92:	73 07       	cpc	r23, r19
   1fd94:	08 f4       	brcc	.+2      	; 0x1fd98 <isp_read_block+0x168>
   1fd96:	9b 01       	movw	r18, r22
   1fd98:	f7 01       	movw	r30, r14
   1fd9a:	40 e0       	ldi	r20, 0x00	; 0
   1fd9c:	50 e0       	ldi	r21, 0x00	; 0
   1fd9e:	ae e1       	ldi	r26, 0x1E	; 30
   1fda0:	71 e8       	ldi	r23, 0x81	; 129
   1fda2:	67 e9       	ldi	r22, 0x97	; 151
   1fda4:	27 c0       	rjmp	.+78     	; 0x1fdf4 <isp_read_block+0x1c4>
   1fda6:	80 91 52 02 	lds	r24, 0x0252
   1fdaa:	90 91 53 02 	lds	r25, 0x0253
   1fdae:	00 97       	sbiw	r24, 0x00	; 0
   1fdb0:	11 f4       	brne	.+4      	; 0x1fdb6 <isp_read_block+0x186>
   1fdb2:	a0 83       	st	Z, r26
   1fdb4:	0a c0       	rjmp	.+20     	; 0x1fdca <isp_read_block+0x19a>
   1fdb6:	81 30       	cpi	r24, 0x01	; 1
   1fdb8:	91 05       	cpc	r25, r1
   1fdba:	11 f4       	brne	.+4      	; 0x1fdc0 <isp_read_block+0x190>
   1fdbc:	70 83       	st	Z, r23
   1fdbe:	05 c0       	rjmp	.+10     	; 0x1fdca <isp_read_block+0x19a>
   1fdc0:	02 97       	sbiw	r24, 0x02	; 2
   1fdc2:	11 f4       	brne	.+4      	; 0x1fdc8 <isp_read_block+0x198>
   1fdc4:	60 83       	st	Z, r22
   1fdc6:	01 c0       	rjmp	.+2      	; 0x1fdca <isp_read_block+0x19a>
   1fdc8:	10 82       	st	Z, r1
   1fdca:	80 91 52 02 	lds	r24, 0x0252
   1fdce:	90 91 53 02 	lds	r25, 0x0253
   1fdd2:	01 96       	adiw	r24, 0x01	; 1
   1fdd4:	90 93 53 02 	sts	0x0253, r25
   1fdd8:	80 93 52 02 	sts	0x0252, r24
   1fddc:	80 91 54 02 	lds	r24, 0x0254
   1fde0:	90 91 55 02 	lds	r25, 0x0255
   1fde4:	01 97       	sbiw	r24, 0x01	; 1
   1fde6:	90 93 55 02 	sts	0x0255, r25
   1fdea:	80 93 54 02 	sts	0x0254, r24
   1fdee:	4f 5f       	subi	r20, 0xFF	; 255
   1fdf0:	5f 4f       	sbci	r21, 0xFF	; 255
   1fdf2:	31 96       	adiw	r30, 0x01	; 1
   1fdf4:	42 17       	cp	r20, r18
   1fdf6:	53 07       	cpc	r21, r19
   1fdf8:	b1 f6       	brne	.-84     	; 0x1fda6 <isp_read_block+0x176>
   1fdfa:	8b c0       	rjmp	.+278    	; 0x1ff12 <isp_read_block+0x2e2>
   1fdfc:	20 91 54 02 	lds	r18, 0x0254
   1fe00:	30 91 55 02 	lds	r19, 0x0255
   1fe04:	62 17       	cp	r22, r18
   1fe06:	73 07       	cpc	r23, r19
   1fe08:	08 f4       	brcc	.+2      	; 0x1fe0c <isp_read_block+0x1dc>
   1fe0a:	9b 01       	movw	r18, r22
   1fe0c:	f7 01       	movw	r30, r14
   1fe0e:	40 e0       	ldi	r20, 0x00	; 0
   1fe10:	50 e0       	ldi	r21, 0x00	; 0
   1fe12:	a4 e0       	ldi	r26, 0x04	; 4
   1fe14:	71 ed       	ldi	r23, 0xD1	; 209
   1fe16:	62 ed       	ldi	r22, 0xD2	; 210
   1fe18:	22 c0       	rjmp	.+68     	; 0x1fe5e <isp_read_block+0x22e>
   1fe1a:	80 91 52 02 	lds	r24, 0x0252
   1fe1e:	90 91 53 02 	lds	r25, 0x0253
   1fe22:	00 97       	sbiw	r24, 0x00	; 0
   1fe24:	11 f4       	brne	.+4      	; 0x1fe2a <isp_read_block+0x1fa>
   1fe26:	a0 83       	st	Z, r26
   1fe28:	05 c0       	rjmp	.+10     	; 0x1fe34 <isp_read_block+0x204>
   1fe2a:	01 97       	sbiw	r24, 0x01	; 1
   1fe2c:	11 f4       	brne	.+4      	; 0x1fe32 <isp_read_block+0x202>
   1fe2e:	70 83       	st	Z, r23
   1fe30:	01 c0       	rjmp	.+2      	; 0x1fe34 <isp_read_block+0x204>
   1fe32:	60 83       	st	Z, r22
   1fe34:	80 91 52 02 	lds	r24, 0x0252
   1fe38:	90 91 53 02 	lds	r25, 0x0253
   1fe3c:	01 96       	adiw	r24, 0x01	; 1
   1fe3e:	90 93 53 02 	sts	0x0253, r25
   1fe42:	80 93 52 02 	sts	0x0252, r24
   1fe46:	80 91 54 02 	lds	r24, 0x0254
   1fe4a:	90 91 55 02 	lds	r25, 0x0255
   1fe4e:	01 97       	sbiw	r24, 0x01	; 1
   1fe50:	90 93 55 02 	sts	0x0255, r25
   1fe54:	80 93 54 02 	sts	0x0254, r24
   1fe58:	4f 5f       	subi	r20, 0xFF	; 255
   1fe5a:	5f 4f       	sbci	r21, 0xFF	; 255
   1fe5c:	31 96       	adiw	r30, 0x01	; 1
   1fe5e:	42 17       	cp	r20, r18
   1fe60:	53 07       	cpc	r21, r19
   1fe62:	d9 f6       	brne	.-74     	; 0x1fe1a <isp_read_block+0x1ea>
   1fe64:	56 c0       	rjmp	.+172    	; 0x1ff12 <isp_read_block+0x2e2>
   1fe66:	00 91 54 02 	lds	r16, 0x0254
   1fe6a:	10 91 55 02 	lds	r17, 0x0255
   1fe6e:	60 17       	cp	r22, r16
   1fe70:	71 07       	cpc	r23, r17
   1fe72:	08 f4       	brcc	.+2      	; 0x1fe76 <isp_read_block+0x246>
   1fe74:	8b 01       	movw	r16, r22
   1fe76:	c0 e0       	ldi	r28, 0x00	; 0
   1fe78:	d0 e0       	ldi	r29, 0x00	; 0
   1fe7a:	1e c0       	rjmp	.+60     	; 0x1feb8 <isp_read_block+0x288>
   1fe7c:	80 91 52 02 	lds	r24, 0x0252
   1fe80:	90 91 53 02 	lds	r25, 0x0253
   1fe84:	80 51       	subi	r24, 0x10	; 16
   1fe86:	90 40       	sbci	r25, 0x00	; 0
   1fe88:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1fe8c:	f7 01       	movw	r30, r14
   1fe8e:	81 93       	st	Z+, r24
   1fe90:	7f 01       	movw	r14, r30
   1fe92:	80 91 52 02 	lds	r24, 0x0252
   1fe96:	90 91 53 02 	lds	r25, 0x0253
   1fe9a:	01 96       	adiw	r24, 0x01	; 1
   1fe9c:	90 93 53 02 	sts	0x0253, r25
   1fea0:	80 93 52 02 	sts	0x0252, r24
   1fea4:	80 91 54 02 	lds	r24, 0x0254
   1fea8:	90 91 55 02 	lds	r25, 0x0255
   1feac:	01 97       	sbiw	r24, 0x01	; 1
   1feae:	90 93 55 02 	sts	0x0255, r25
   1feb2:	80 93 54 02 	sts	0x0254, r24
   1feb6:	21 96       	adiw	r28, 0x01	; 1
   1feb8:	c0 17       	cp	r28, r16
   1feba:	d1 07       	cpc	r29, r17
   1febc:	f9 f6       	brne	.-66     	; 0x1fe7c <isp_read_block+0x24c>
   1febe:	57 cf       	rjmp	.-338    	; 0x1fd6e <isp_read_block+0x13e>
   1fec0:	20 91 54 02 	lds	r18, 0x0254
   1fec4:	30 91 55 02 	lds	r19, 0x0255
   1fec8:	62 17       	cp	r22, r18
   1feca:	73 07       	cpc	r23, r19
   1fecc:	08 f4       	brcc	.+2      	; 0x1fed0 <isp_read_block+0x2a0>
   1fece:	9b 01       	movw	r18, r22
   1fed0:	40 e0       	ldi	r20, 0x00	; 0
   1fed2:	50 e0       	ldi	r21, 0x00	; 0
   1fed4:	d7 01       	movw	r26, r14
   1fed6:	1a c0       	rjmp	.+52     	; 0x1ff0c <isp_read_block+0x2dc>
   1fed8:	e0 91 52 02 	lds	r30, 0x0252
   1fedc:	f0 91 53 02 	lds	r31, 0x0253
   1fee0:	80 81       	ld	r24, Z
   1fee2:	8d 93       	st	X+, r24
   1fee4:	80 91 52 02 	lds	r24, 0x0252
   1fee8:	90 91 53 02 	lds	r25, 0x0253
   1feec:	01 96       	adiw	r24, 0x01	; 1
   1feee:	90 93 53 02 	sts	0x0253, r25
   1fef2:	80 93 52 02 	sts	0x0252, r24
   1fef6:	80 91 54 02 	lds	r24, 0x0254
   1fefa:	90 91 55 02 	lds	r25, 0x0255
   1fefe:	01 97       	sbiw	r24, 0x01	; 1
   1ff00:	90 93 55 02 	sts	0x0255, r25
   1ff04:	80 93 54 02 	sts	0x0254, r24
   1ff08:	4f 5f       	subi	r20, 0xFF	; 255
   1ff0a:	5f 4f       	sbci	r21, 0xFF	; 255
   1ff0c:	42 17       	cp	r20, r18
   1ff0e:	53 07       	cpc	r21, r19
   1ff10:	19 f7       	brne	.-58     	; 0x1fed8 <isp_read_block+0x2a8>
   1ff12:	80 91 54 02 	lds	r24, 0x0254
   1ff16:	90 91 55 02 	lds	r25, 0x0255
   1ff1a:	89 2b       	or	r24, r25
   1ff1c:	39 f4       	brne	.+14     	; 0x1ff2c <isp_read_block+0x2fc>
   1ff1e:	30 93 55 02 	sts	0x0255, r19
   1ff22:	20 93 54 02 	sts	0x0254, r18
   1ff26:	2e cf       	rjmp	.-420    	; 0x1fd84 <isp_read_block+0x154>
   1ff28:	8f ef       	ldi	r24, 0xFF	; 255
   1ff2a:	01 c0       	rjmp	.+2      	; 0x1ff2e <isp_read_block+0x2fe>
   1ff2c:	80 e0       	ldi	r24, 0x00	; 0
   1ff2e:	99 27       	eor	r25, r25
   1ff30:	df 91       	pop	r29
   1ff32:	cf 91       	pop	r28
   1ff34:	1f 91       	pop	r17
   1ff36:	0f 91       	pop	r16
   1ff38:	ff 90       	pop	r15
   1ff3a:	ef 90       	pop	r14
   1ff3c:	08 95       	ret

0001ff3e <isp_memory_erase>:
   1ff3e:	80 91 56 02 	lds	r24, 0x0256
   1ff42:	81 30       	cpi	r24, 0x01	; 1
   1ff44:	69 f0       	breq	.+26     	; 0x1ff60 <isp_memory_erase+0x22>
   1ff46:	81 30       	cpi	r24, 0x01	; 1
   1ff48:	18 f0       	brcs	.+6      	; 0x1ff50 <isp_memory_erase+0x12>
   1ff4a:	84 30       	cpi	r24, 0x04	; 4
   1ff4c:	11 f5       	brne	.+68     	; 0x1ff92 <isp_memory_erase+0x54>
   1ff4e:	12 c0       	rjmp	.+36     	; 0x1ff74 <isp_memory_erase+0x36>
   1ff50:	0e 94 8d f1 	call	0x1e31a	; 0x1e31a <flash_full_erase>
   1ff54:	6f ef       	ldi	r22, 0xFF	; 255
   1ff56:	81 ef       	ldi	r24, 0xF1	; 241
   1ff58:	9f ef       	ldi	r25, 0xFF	; 255
   1ff5a:	0e 94 18 fd 	call	0x1fa30	; 0x1fa30 <put_conf_byte>
   1ff5e:	08 c0       	rjmp	.+16     	; 0x1ff70 <isp_memory_erase+0x32>
   1ff60:	81 ef       	ldi	r24, 0xF1	; 241
   1ff62:	9f ef       	ldi	r25, 0xFF	; 255
   1ff64:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1ff68:	8f 3f       	cpi	r24, 0xFF	; 255
   1ff6a:	99 f4       	brne	.+38     	; 0x1ff92 <isp_memory_erase+0x54>
   1ff6c:	0e 94 4a f8 	call	0x1f094	; 0x1f094 <eeprom_full_erase>
   1ff70:	81 e0       	ldi	r24, 0x01	; 1
   1ff72:	10 c0       	rjmp	.+32     	; 0x1ff94 <isp_memory_erase+0x56>
   1ff74:	81 ef       	ldi	r24, 0xF1	; 241
   1ff76:	9f ef       	ldi	r25, 0xFF	; 255
   1ff78:	0e 94 21 fd 	call	0x1fa42	; 0x1fa42 <get_conf_byte>
   1ff7c:	8f 3f       	cpi	r24, 0xFF	; 255
   1ff7e:	49 f4       	brne	.+18     	; 0x1ff92 <isp_memory_erase+0x54>
   1ff80:	4a e0       	ldi	r20, 0x0A	; 10
   1ff82:	50 e0       	ldi	r21, 0x00	; 0
   1ff84:	60 ef       	ldi	r22, 0xF0	; 240
   1ff86:	7f ef       	ldi	r23, 0xFF	; 255
   1ff88:	80 e0       	ldi	r24, 0x00	; 0
   1ff8a:	91 e0       	ldi	r25, 0x01	; 1
   1ff8c:	0e 94 0f fd 	call	0x1fa1e	; 0x1fa1e <put_conf_block>
   1ff90:	ef cf       	rjmp	.-34     	; 0x1ff70 <isp_memory_erase+0x32>
   1ff92:	80 e0       	ldi	r24, 0x00	; 0
   1ff94:	99 27       	eor	r25, r25
   1ff96:	08 95       	ret

0001ff98 <__udivmodsi4>:
   1ff98:	a1 e2       	ldi	r26, 0x21	; 33
   1ff9a:	1a 2e       	mov	r1, r26
   1ff9c:	aa 1b       	sub	r26, r26
   1ff9e:	bb 1b       	sub	r27, r27
   1ffa0:	fd 01       	movw	r30, r26
   1ffa2:	0d c0       	rjmp	.+26     	; 0x1ffbe <__udivmodsi4_ep>

0001ffa4 <__udivmodsi4_loop>:
   1ffa4:	aa 1f       	adc	r26, r26
   1ffa6:	bb 1f       	adc	r27, r27
   1ffa8:	ee 1f       	adc	r30, r30
   1ffaa:	ff 1f       	adc	r31, r31
   1ffac:	a2 17       	cp	r26, r18
   1ffae:	b3 07       	cpc	r27, r19
   1ffb0:	e4 07       	cpc	r30, r20
   1ffb2:	f5 07       	cpc	r31, r21
   1ffb4:	20 f0       	brcs	.+8      	; 0x1ffbe <__udivmodsi4_ep>
   1ffb6:	a2 1b       	sub	r26, r18
   1ffb8:	b3 0b       	sbc	r27, r19
   1ffba:	e4 0b       	sbc	r30, r20
   1ffbc:	f5 0b       	sbc	r31, r21

0001ffbe <__udivmodsi4_ep>:
   1ffbe:	66 1f       	adc	r22, r22
   1ffc0:	77 1f       	adc	r23, r23
   1ffc2:	88 1f       	adc	r24, r24
   1ffc4:	99 1f       	adc	r25, r25
   1ffc6:	1a 94       	dec	r1
   1ffc8:	69 f7       	brne	.-38     	; 0x1ffa4 <__udivmodsi4_loop>
   1ffca:	60 95       	com	r22
   1ffcc:	70 95       	com	r23
   1ffce:	80 95       	com	r24
   1ffd0:	90 95       	com	r25
   1ffd2:	9b 01       	movw	r18, r22
   1ffd4:	ac 01       	movw	r20, r24
   1ffd6:	bd 01       	movw	r22, r26
   1ffd8:	cf 01       	movw	r24, r30
   1ffda:	08 95       	ret
Disassembly of section .flashapi:

0001fffa <flash_api_wr_block>:
//! @return none
//!
//------------------------------------------------------------------------------
void flash_api_wr_block(U8* src, U16 dest, U16 byte_nb)
{
   1fffa:	0e 94 b5 f1 	call	0x1e36a	; 0x1e36a <flash_wr_block>
   1fffe:	08 95       	ret
